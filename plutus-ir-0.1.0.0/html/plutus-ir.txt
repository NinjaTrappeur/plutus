-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Plutus IR language
--   
--   Plutus IR language library and compiler to Plutus Core.
@package plutus-ir
@version 0.1.0.0

module Language.PlutusIR

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName a
TyName :: Name a -> TyName a
[unTyName] :: TyName a -> Name a

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name a
Name :: a -> Text -> Unique -> Name a
[nameAttribute] :: Name a -> a

-- | The identifier name, for use in error messages.
[nameString] :: Name a -> Text

-- | A <a>Unique</a> assigned to the name during lexing, allowing for cheap
--   comparisons in the compiler.
[nameUnique] :: Name a -> Unique

-- | A "variable declaration", i.e. a name and a type for a variable.
data VarDecl (tyname :: * -> *) (name :: * -> *) a
VarDecl :: a -> name a -> Type tyname a -> VarDecl a
[varDeclAnn] :: VarDecl a -> a
[varDeclName] :: VarDecl a -> name a
[varDeclType] :: VarDecl a -> Type tyname a

-- | A "type variable declaration", i.e. a name and a kind for a type
--   variable.
data TyVarDecl (tyname :: * -> *) a
TyVarDecl :: a -> tyname a -> Kind a -> TyVarDecl a
[tyVarDeclAnn] :: TyVarDecl a -> a
[tyVarDeclName] :: TyVarDecl a -> tyname a
[tyVarDeclKind] :: TyVarDecl a -> Kind a
varDeclNameString :: VarDecl name Name a -> String
tyVarDeclNameString :: TyVarDecl TyName a -> String

-- | Kinds. Each type has an associated kind.
data Kind a
Type :: a -> Kind a
KindArrow :: a -> Kind a -> Kind a -> Kind a
Size :: a -> Kind a

-- | A <a>Type</a> assigned to expressions.
data Type (tyname :: * -> *) a
TyVar :: a -> tyname a -> Type a
TyFun :: a -> Type tyname a -> Type tyname a -> Type a

-- | Fix-point type, for constructing self-recursive types
TyIFix :: a -> Type tyname a -> Type tyname a -> Type a
TyForall :: a -> tyname a -> Kind a -> Type tyname a -> Type a

-- | Builtin type
TyBuiltin :: a -> TypeBuiltin -> Type a

-- | Type-level size
TyInt :: a -> Natural -> Type a
TyLam :: a -> tyname a -> Kind a -> Type tyname a -> Type a
TyApp :: a -> Type tyname a -> Type tyname a -> Type a
data Datatype tyname name a
Datatype :: a -> (TyVarDecl tyname a) -> [TyVarDecl tyname a] -> (name a) -> [VarDecl tyname name a] -> Datatype tyname name a
datatypeNameString :: Datatype TyName name a -> String
data Recursivity
NonRec :: Recursivity
Rec :: Recursivity
data Binding tyname name a
TermBind :: a -> (VarDecl tyname name a) -> (Term tyname name a) -> Binding tyname name a
TypeBind :: a -> (TyVarDecl tyname a) -> (Type tyname a) -> Binding tyname name a
DatatypeBind :: a -> (Datatype tyname name a) -> Binding tyname name a
data Term tyname name a
Let :: a -> Recursivity -> [Binding tyname name a] -> (Term tyname name a) -> Term tyname name a
Var :: a -> (name a) -> Term tyname name a
TyAbs :: a -> (tyname a) -> (Kind a) -> (Term tyname name a) -> Term tyname name a
LamAbs :: a -> (name a) -> (Type tyname a) -> (Term tyname name a) -> Term tyname name a
Apply :: a -> (Term tyname name a) -> (Term tyname name a) -> Term tyname name a
Constant :: a -> (Constant a) -> Term tyname name a
Builtin :: a -> (Builtin a) -> Term tyname name a
TyInst :: a -> (Term tyname name a) -> (Type tyname a) -> Term tyname name a
Error :: a -> (Type tyname a) -> Term tyname name a
IWrap :: a -> (Type tyname a) -> (Type tyname a) -> (Term tyname name a) -> Term tyname name a
Unwrap :: a -> (Term tyname name a) -> Term tyname name a
data Program tyname name a
Program :: a -> (Term tyname name a) -> Program tyname name a
embedIntoIR :: Term tyname name a -> Term tyname name a
instance GHC.Generics.Generic (Language.PlutusIR.Program tyname name a)
instance GHC.Generics.Generic (Language.PlutusIR.Binding tyname name a)
instance (GHC.Classes.Ord (tyname a), GHC.Classes.Eq a, GHC.Classes.Eq (name a)) => GHC.Classes.Eq (Language.PlutusIR.Binding tyname name a)
instance (GHC.Show.Show a, GHC.Show.Show (name a), GHC.Show.Show (tyname a)) => GHC.Show.Show (Language.PlutusIR.Binding tyname name a)
instance (GHC.Base.Functor name, GHC.Base.Functor tyname) => GHC.Base.Functor (Language.PlutusIR.Binding tyname name)
instance GHC.Generics.Generic (Language.PlutusIR.Term tyname name a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (name a), GHC.Classes.Ord (tyname a)) => GHC.Classes.Eq (Language.PlutusIR.Term tyname name a)
instance (GHC.Show.Show a, GHC.Show.Show (name a), GHC.Show.Show (tyname a)) => GHC.Show.Show (Language.PlutusIR.Term tyname name a)
instance (GHC.Base.Functor name, GHC.Base.Functor tyname) => GHC.Base.Functor (Language.PlutusIR.Term tyname name)
instance GHC.Generics.Generic Language.PlutusIR.Recursivity
instance GHC.Classes.Eq Language.PlutusIR.Recursivity
instance GHC.Show.Show Language.PlutusIR.Recursivity
instance GHC.Generics.Generic (Language.PlutusIR.Datatype tyname name a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (name a), GHC.Classes.Ord (tyname a)) => GHC.Classes.Eq (Language.PlutusIR.Datatype tyname name a)
instance (GHC.Show.Show a, GHC.Show.Show (tyname a), GHC.Show.Show (name a)) => GHC.Show.Show (Language.PlutusIR.Datatype tyname name a)
instance (GHC.Base.Functor tyname, GHC.Base.Functor name) => GHC.Base.Functor (Language.PlutusIR.Datatype tyname name)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusIR.Program tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (name a)) => PlutusPrelude.PrettyBy (Language.PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (Language.PlutusIR.Program tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassic (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassic (name a)) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusIR.Program tyname name a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusIR.Binding tyname name a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusIR.Term tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (name a)) => PlutusPrelude.PrettyBy (Language.PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (Language.PlutusIR.Binding tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (name a)) => PlutusPrelude.PrettyBy (Language.PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (Language.PlutusIR.Term tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassic (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassic (name a)) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusIR.Binding tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassic (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassic (name a)) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusIR.Term tyname name a)
instance Codec.Serialise.Class.Serialise Language.PlutusIR.Recursivity
instance PlutusPrelude.PrettyBy (Language.PlutusCore.Pretty.Classic.PrettyConfigClassic configName) Language.PlutusIR.Recursivity
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusIR.Datatype tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (name a)) => PlutusPrelude.PrettyBy (Language.PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (Language.PlutusIR.Datatype tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassic (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassic (name a)) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusIR.Datatype tyname name a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (name a)) => PlutusPrelude.PrettyBy (Language.PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance Language.PlutusCore.Pretty.Classic.PrettyClassicBy configName (tyname a) => PlutusPrelude.PrettyBy (Language.PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance Language.PlutusCore.Pretty.Classic.PrettyClassic (tyname a) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance (Language.PlutusCore.Pretty.Classic.PrettyClassic (tyname a), Language.PlutusCore.Pretty.Classic.PrettyClassic (name a)) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.MkPlc.VarDecl tyname name a)

module Language.PlutusIR.Compiler.Names
safeFreshName :: MonadQuote m => a -> Text -> m (Name a)
safeFreshTyName :: MonadQuote m => a -> Text -> m (TyName a)

module Language.PlutusIR.MkPir

-- | A definition. Pretty much just a pair with more descriptive names.
data Def var val
Def :: var -> val -> Def var val
[defVar] :: Def var val -> var
[defVal] :: Def var val -> val

-- | A term definition as a variable.
type TermDef tyname name a = Def (VarDecl tyname name a) (Term tyname name a)

-- | A type definition as a type variable.
type TypeDef tyname a = Def (TyVarDecl tyname a) (Type tyname a)

-- | A datatype definition as a type variable.
type DatatypeDef tyname name a = Def (TyVarDecl tyname a) (Datatype tyname name a)

-- | Make a <a>Var</a> referencing the given <a>VarDecl</a>.
mkVar :: a -> VarDecl tyname name a -> Term tyname name a

-- | Make a <a>TyVar</a> referencing the given <a>TyVarDecl</a>.
mkTyVar :: () => a -> TyVarDecl tyname a -> Type tyname a

-- | Make a let binding, unless the list of bindings is empty, in which
--   case just return the underlying term.
mkLet :: a -> Recursivity -> [Binding tyname name a] -> Term tyname name a -> Term tyname name a

-- | Universally quantify a list of names.
mkIterTyForall :: a -> [TyVarDecl tyname a] -> Type tyname a -> Type tyname a

-- | Lambda abstract a list of names.
mkIterTyLam :: a -> [TyVarDecl tyname a] -> Type tyname a -> Type tyname a

-- | Make an iterated application.
mkIterApp :: a -> Term tyname name a -> [Term tyname name a] -> Term tyname name a

-- | Make an iterated function type.
mkIterTyFun :: a -> [Type tyname a] -> Type tyname a -> Type tyname a

-- | Lambda abstract a list of names.
mkIterLamAbs :: a -> [VarDecl tyname name a] -> Term tyname name a -> Term tyname name a

-- | Make an iterated instantiation.
mkIterInst :: a -> Term tyname name a -> [Type tyname a] -> Term tyname name a

-- | Type abstract a list of names.
mkIterTyAbs :: a -> [TyVarDecl tyname a] -> Term tyname name a -> Term tyname name a

-- | Make an iterated type application.
mkIterTyApp :: a -> Type tyname a -> [Type tyname a] -> Type tyname a


-- | Support for generating PIR with global definitions with dependencies
--   between them.
module Language.PlutusIR.Compiler.Definitions
data DefT key ann m a
class (Monad m, Ord key) => MonadDefs key ann m | m -> key
liftDef :: MonadDefs key ann m => DefT key ann Identity a -> m a
liftDef :: (MonadDefs key ann m, MonadDefs key ann n, MonadTrans t, t n ~ m) => DefT key ann Identity a -> m a
runDefT :: (Monad m, Ord key) => ann -> DefT key ann m (Term TyName Name ann) -> m (Term TyName Name ann)
defineTerm :: MonadDefs key ann m => key -> TermDef TyName Name ann -> Set key -> m ()
defineType :: MonadDefs key ann m => key -> TypeDef TyName ann -> Set key -> m ()
defineDatatype :: forall key ann m. MonadDefs key ann m => key -> DatatypeDef TyName Name ann -> Set key -> m ()
recordAlias :: forall key ann m. MonadDefs key ann m => key -> m ()
lookupType :: (MonadDefs key ann m) => ann -> key -> m (Maybe (Type TyName ann))
lookupTerm :: (MonadDefs key ann m) => ann -> key -> m (Maybe (Term TyName Name ann))
lookupConstructors :: (MonadDefs key ann m) => ann -> key -> m (Maybe [Term TyName Name ann])
lookupDestructor :: (MonadDefs key ann m) => ann -> key -> m (Maybe (Term TyName Name ann))
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Language.PlutusIR.Compiler.Definitions.DefT key ann m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Language.PlutusIR.Compiler.Definitions.DefT key ann m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Language.PlutusIR.Compiler.Definitions.DefT key ann m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Language.PlutusIR.Compiler.Definitions.DefState key ann) (Language.PlutusIR.Compiler.Definitions.DefT key ann m)
instance Control.Monad.Morph.MFunctor (Language.PlutusIR.Compiler.Definitions.DefT key ann)
instance Control.Monad.Trans.Class.MonadTrans (Language.PlutusIR.Compiler.Definitions.DefT key ann)
instance GHC.Base.Monad m => GHC.Base.Monad (Language.PlutusIR.Compiler.Definitions.DefT key ann m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Language.PlutusIR.Compiler.Definitions.DefT key ann m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.PlutusIR.Compiler.Definitions.DefT key ann m)
instance (GHC.Classes.Ord key, GHC.Base.Monad m) => Language.PlutusIR.Compiler.Definitions.MonadDefs key ann (Language.PlutusIR.Compiler.Definitions.DefT key ann m)
instance Language.PlutusIR.Compiler.Definitions.MonadDefs key ann m => Language.PlutusIR.Compiler.Definitions.MonadDefs key ann (Control.Monad.Trans.State.Lazy.StateT s m)
instance Language.PlutusIR.Compiler.Definitions.MonadDefs key ann m => Language.PlutusIR.Compiler.Definitions.MonadDefs key ann (Control.Monad.Trans.Except.ExceptT e m)
instance Language.PlutusIR.Compiler.Definitions.MonadDefs key ann m => Language.PlutusIR.Compiler.Definitions.MonadDefs key ann (Control.Monad.Trans.Reader.ReaderT r m)


-- | Optimization passes for removing dead code, mainly dead let bindings.
module Language.PlutusIR.Optimizer.DeadCode

-- | Remove all the dead let bindings in a term.
removeDeadBindings :: (HasUnique (name a) TermUnique, HasUnique (tyname a) TypeUnique) => Term tyname name a -> Term tyname name a


-- | Implements naive substitution functions for replacing type and term
--   variables.
module Language.PlutusIR.Transform.Substitute

-- | Naively substitute names using the given functions (i.e. do not
--   account for scoping).
substTerm :: (tyname a -> Maybe (Type tyname a)) -> (name a -> Maybe (Term tyname name a)) -> Term tyname name a -> Term tyname name a

-- | Naively substitute names using the given function (i.e. do not account
--   for scoping).
substTy :: () => tyname a -> Maybe Type tyname a -> Type tyname a -> Type tyname a

-- | Naively substitute names using the given functions (i.e. do not
--   account for scoping).
substBinding :: (tyname a -> Maybe (Type tyname a)) -> (name a -> Maybe (Term tyname name a)) -> Binding tyname name a -> Binding tyname name a


-- | Implements a PIR-to-PIR transformation that makes all recursive term
--   definitions compilable to PLC. See Note [Thunking recursions] for
--   details.
module Language.PlutusIR.Transform.ThunkRecursions
thunkRecursionsTerm :: MonadQuote m => Term TyName Name a -> m (Term TyName Name a)
instance GHC.Show.Show Language.PlutusIR.Transform.ThunkRecursions.ThunkedNonTermBinding
instance GHC.Exception.Exception Language.PlutusIR.Transform.ThunkRecursions.ThunkedNonTermBinding

module Language.PlutusIR.Compiler

-- | Compile a <a>Term</a> into a PLC Term. Note: the result *does* have
--   globally unique names.
compileTerm :: Compiling m e a => Term TyName Name a -> m (PLCTerm a)

-- | Compile a <a>Program</a> into a PLC Program. Note: the result *does*
--   have globally unique names.
compileProgram :: Compiling m e a => Program TyName Name a -> m (Program TyName Name (Provenance a))
type Compiling m e a = (Monad m, MonadReader (Provenance a) m, AsError e (Provenance a), MonadError e m, MonadQuote m)
data Error a

-- | A generic compilation error.
CompilationError :: a -> Text -> Error a

-- | An error relating specifically to an unsupported feature.
UnsupportedError :: a -> Text -> Error a

-- | An error from running some PLC function, lifted into this error type
--   for convenience.
PLCError :: (Error a) -> Error a
class AsError r_aHxU a_aHkL | r_aHxU -> a_aHkL
_Error :: AsError r_aHxU a_aHkL => Prism' r_aHxU (Error a_aHkL)
_CompilationError :: AsError r_aHxU a_aHkL => Prism' r_aHxU (a_aHkL, Text)
_UnsupportedError :: AsError r_aHxU a_aHkL => Prism' r_aHxU (a_aHkL, Text)
_PLCError :: AsError r_aHxU a_aHkL => Prism' r_aHxU (Error a_aHkL)

-- | Indicates where a value comes from.
--   
--   This is either an original annotation or a pieces of context
--   explaining how the term relates to a previous <a>Provenance</a>. We
--   also provide <a>NoProvenance</a> for convenience.
--   
--   The provenance should always be just the original annotation, if we
--   have one. It should only be another kind of provenance if we're in the
--   process of generating some term that doesn't correspond directly to a
--   term in the original AST.
data Provenance a
Original :: a -> Provenance a
LetBinding :: Recursivity -> (Provenance a) -> Provenance a
TermBinding :: String -> (Provenance a) -> Provenance a
TypeBinding :: String -> (Provenance a) -> Provenance a
DatatypeComponent :: DatatypeComponent -> (Provenance a) -> Provenance a
NoProvenance :: Provenance a

module Language.PlutusIR.Value

-- | Whether the given PIR term is (will compile to) a PLC term value.
isTermValue :: Term tyname name a -> Bool
