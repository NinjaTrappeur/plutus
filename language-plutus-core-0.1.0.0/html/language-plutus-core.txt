-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Language library for Plutus Core
--   
--   Pretty-printer, parser, and typechecker for Plutus Core.
@package language-plutus-core
@version 0.1.0.0


-- | Hash functions for lazy [[Data.ByteString.Lazy.ByteString]]s
module Data.ByteString.Lazy.Hash

-- | Hash a [[BSL.ByteString]] using the SHA-256 hash function.
sha2 :: ByteString -> ByteString

-- | Hash a [[BSL.ByteString]] using the SHA3-256 hash function.
sha3 :: ByteString -> ByteString

module PlutusPrelude

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: () => a -> a -> b -> b
infixl 1 &

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 &&&

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: () => a -> a -> Bool -> a

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => a -> b -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => b -> c -> p a b -> p a c
on :: () => b -> b -> c -> a -> b -> a -> a -> c
infixl 0 `on`

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: () => Maybe a -> Bool

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => b -> a -> b -> b -> t a -> b

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
throw :: Exception e => e -> a

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
join :: Monad m => m m a -> m a

-- | Right-to-left Kleisli composition of monads.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => b -> m c -> a -> m b -> a -> m c
infixr 1 <=<

-- | Flipped version of <a>&lt;$</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with a
--   constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with a constant <tt>String</tt>, resulting in an
--   <tt><tt>Either</tt> <tt>Int</tt> <tt>String</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <tt>String</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: () => b -> Either a b -> b

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: () => Either a b -> Bool

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><tt>Maybe</tt> <tt>Int</tt></tt> with
--   unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><tt>Either</tt> <tt>Int</tt>
--   <tt>Int</tt></tt> with unit, resulting in an <tt><tt>Either</tt>
--   <tt>Int</tt> '()'</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Makes an effectful function ignore its result value and return its
--   input value.
through :: Functor f => (a -> f b) -> (a -> f a)

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
coerce :: Coercible a b => a -> b

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a

-- | A class of types that can be fully evaluated.
class NFData a

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^20 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a

-- | 8-bit unsigned integer type
data Word8

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <tt>&lt;$&gt;</tt> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: * -> *)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
newtype PairT b f a
PairT :: f (b, a) -> PairT b f a
[unPairT] :: PairT b f a -> f (b, a)

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k0) (b :: k0)

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
type Lens' s a = Lens s s a a
lens :: () => s -> a -> s -> b -> t -> Lens s t a b
(^.) :: () => s -> Getting a s a -> a
view :: MonadReader s m => Getting a s a -> m a
(.~) :: () => ASetter s t a b -> b -> s -> t
set :: () => ASetter s t a b -> b -> s -> t
(%~) :: () => ASetter s t a b -> a -> b -> s -> t
over :: () => ASetter s t a b -> a -> b -> s -> t

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: () => String -> a -> a
(.*) :: () => c -> d -> a -> b -> c -> a -> b -> d
(<<$>>) :: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
infixl 4 <<$>>
(<<*>>) :: (Applicative f1, Applicative f2) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
infixl 4 <<*>>

-- | Fold a monadic function over a <a>Foldable</a>. The monadic version of
--   <a>foldMap</a>.
foldMapM :: (Foldable f, Monad m, Monoid b) => (a -> m b) -> f a -> m b

-- | Make sure your <a>Applicative</a> is sufficiently lazy!
repeatM :: Applicative f => Int -> f a -> f [a]
(?) :: Alternative f => Bool -> a -> f a
infixr 2 ?

-- | Like a version of <tt>everywhere</tt> for recursion schemes.
hoist :: (Recursive t, Corecursive t) => (Base t t -> Base t t) -> t -> t
(<+>) :: () => Doc ann -> Doc ann -> Doc ann
parens :: () => Doc ann -> Doc ann
brackets :: () => Doc ann -> Doc ann
hardline :: () => Doc ann
squotes :: () => Doc ann -> Doc ann
list :: () => [Doc ann] -> Doc ann
data Doc ann
strToBs :: String -> ByteString
bsToStr :: ByteString -> String
indent :: () => Int -> Doc ann -> Doc ann
class Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann

-- | This class is used in order to provide default implementations of
--   <a>PrettyBy</a> for particular <tt>config</tt>s. Whenever a
--   <tt>Config</tt> is a sum type of <tt>Subconfig1</tt>,
--   <tt>Subconfig2</tt>, etc, we can define a single
--   <a>DefaultPrettyBy</a> instance and then derive <tt>PrettyBy Config
--   a</tt> for each <tt>a</tt> provided the <tt>a</tt> implements the
--   <tt>PrettyBy Subconfig1</tt>, <tt>PrettyBy Subconfig2</tt>, etc
--   instances.
--   
--   Example:
--   
--   <pre>
--   data Config = Subconfig1 Subconfig1 | Subconfig2 Subconfig2
--   
--   instance (PrettyBy Subconfig1 a, PrettyBy Subconfig2 a) =&gt; DefaultPrettyBy Config a where
--       defaultPrettyBy (Subconfig1 subconfig1) = prettyBy subconfig1
--       defaultPrettyBy (Subconfig2 subconfig2) = prettyBy subconfig2
--   </pre>
--   
--   Now having in scope <tt>PrettyBy Subconfig1 A</tt> and <tt>PrettyBy
--   Subconfig2 A</tt> and the same instances for <tt>B</tt> we can write
--   
--   <pre>
--   instance PrettyBy Config A
--   instance PrettyBy Config B
--   </pre>
--   
--   and the instances will be derived for us.
class DefaultPrettyBy config a
defaultPrettyBy :: DefaultPrettyBy config a => config -> a -> Doc ann

-- | Overloaded configurable conversion to <a>Doc</a>. I.e. like
--   <a>Pretty</a>, but parameterized by a <tt>config</tt>. This class is
--   interoperable with the <a>Pretty</a> class via
--   <a>PrettyConfigIgnore</a> and <tt>PrettyConfigAttatch</tt>.
class PrettyBy config a
prettyBy :: PrettyBy config a => config -> a -> Doc ann
prettyBy :: (PrettyBy config a, DefaultPrettyBy config a) => config -> a -> Doc ann

-- | A newtype wrapper around <tt>a</tt> which point is to provide a
--   'PrettyBy config' instance for anything that has a <a>Pretty</a>
--   instance.
newtype PrettyConfigIgnore a
PrettyConfigIgnore :: a -> PrettyConfigIgnore a
[unPrettyConfigIgnore] :: PrettyConfigIgnore a -> a

-- | A config together with some value. The point is to provide a
--   <a>Pretty</a> instance for anything that has a 'PrettyBy config'
--   instance.
data PrettyConfigAttach config a
PrettyConfigAttach :: config -> a -> PrettyConfigAttach config a

-- | Render a <a>Doc</a> as <a>String</a>.
docString :: Doc a -> String

-- | Render a <a>Doc</a> as <tt>Text</tt>.
docText :: Doc a -> Text

-- | Render a value as <a>String</a>.
prettyString :: Pretty a => a -> String

-- | Render a value as strict <tt>Text</tt>.
prettyText :: Pretty a => a -> Text

-- | Render a value as <a>String</a>.
prettyStringBy :: PrettyBy config a => config -> a -> String

-- | Render a value as strict <tt>Text</tt>.
prettyTextBy :: PrettyBy config a => config -> a -> Text

-- | This prints a document enclosed by brackets, possibly indenting the
--   output on a new line if it does not fit.
brackets' :: Doc a -> Doc a

-- | This prints a document enclosed by braces, possibly indenting the
--   output on a new line if it does not fit.
braces' :: Doc a -> Doc a

-- | This is the same as <a>vsep</a>, but it <a>group</a>s the output, so
--   that documents are printed on the same line when possible.
vsep' :: [Doc a] -> Doc a

-- | This prints a document enclosed by parentheses, aligning the opening
--   and closing parentheses.
parens' :: Doc a -> Doc a

-- | This prints both documents on the same line separated by a space if
--   they can fit, and behaves like <a>&lt;//&gt;</a> otherwise.
(</>) :: Doc a -> Doc a -> Doc a
infixr 5 </>

-- | This operator prints <tt>a</tt> and then prints <tt>b</tt> indented on
--   a new line
(<//>) :: Doc a -> Doc a -> Doc a
infixr 5 <//>

-- | The integer square root. Throws an <a>error</a> on negative input.
isqrt :: Integer -> Integer

-- | The integer square root that acts on negative numbers like this:
--   
--   <pre>
--   &gt;&gt;&gt; iasqrt (-4)
--   -2
--   </pre>
iasqrt :: Integer -> Integer

-- | Compute the maximal <tt>p</tt> such that <tt>b ^ p &lt;= x</tt>.
ilogFloor :: Integer -> Integer -> Integer

-- | Compute the minimal <tt>p</tt> such that <tt>x &lt;= b ^ p</tt>.
ilogRound :: Integer -> Integer -> Integer

-- | A command suitable for use in GHCi as an interactive printer.
printPretty :: Pretty a => a -> IO ()
showText :: Show a => a -> Text
instance GHC.Base.Functor f => GHC.Base.Functor (PlutusPrelude.PairT b f)
instance PlutusPrelude.PrettyBy config a => Data.Text.Prettyprint.Doc.Internal.Pretty (PlutusPrelude.PrettyConfigAttach config a)
instance Data.Text.Prettyprint.Doc.Internal.Pretty a => PlutusPrelude.PrettyBy config (PlutusPrelude.PrettyConfigIgnore a)
instance PlutusPrelude.PrettyBy config a => PlutusPrelude.PrettyBy config [a]

module Language.PlutusCore.Name

-- | An <a>IdentifierState</a> includes a map indexed by <a>Int</a>s as
--   well as a map indexed by <tt>ByteString</tt>s. It is used during
--   parsing and renaming.
type IdentifierState = (IntMap ByteString, Map ByteString Unique, Unique)

-- | A unique identifier
newtype Unique
Unique :: Int -> Unique
[unUnique] :: Unique -> Int

-- | The unique of a type-level name.
newtype TypeUnique
TypeUnique :: Unique -> TypeUnique
[unTypeUnique] :: TypeUnique -> Unique

-- | The unique of a term-level name.
newtype TermUnique
TermUnique :: Unique -> TermUnique
[unTermUnique] :: TermUnique -> Unique

-- | Types which have a <a>Unique</a> attached to them, mostly names.
class Coercible Unique unique => HasUnique a unique | a -> unique
unique :: HasUnique a unique => Lens' a unique

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name a
Name :: a -> Text -> Unique -> Name a
[nameAttribute] :: Name a -> a

-- | The identifier name, for use in error messages.
[nameString] :: Name a -> Text

-- | A <a>Unique</a> assigned to the name during lexing, allowing for cheap
--   comparisons in the compiler.
[nameUnique] :: Name a -> Unique

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName a
TyName :: Name a -> TyName a
[unTyName] :: TyName a -> Name a

-- | This is a naïve implementation of interned identifiers. In particular,
--   it indexes things twice (once by <a>Int</a>, once by
--   <tt>ByteString</tt>) to ensure fast lookups while lexing and
--   otherwise.
newIdentifier :: (MonadState IdentifierState m) => ByteString -> m Unique
emptyIdentifierState :: IdentifierState
identifierStateFrom :: Unique -> IdentifierState

-- | Apply a function to the string representation of a <a>Name</a>.
mapNameString :: (Text -> Text) -> Name a -> Name a

-- | Apply a function to the string representation of a <a>TyName</a>.
mapTyNameString :: (Text -> Text) -> TyName a -> TyName a

-- | The default implementation of <a>HasUnique</a> for newtypes.
newtypeUnique :: (Wrapped new, HasUnique (Unwrapped new) unique', Coercible unique' unique) => Lens' new unique

-- | A config that determines how to pretty-print a PLC name.
data PrettyConfigName
PrettyConfigName :: Bool -> Bool -> PrettyConfigName

-- | Whether to show the <a>Unique</a> of a <a>Name</a> or not.
[_pcnShowsUnique] :: PrettyConfigName -> Bool

-- | Whether to show the "With" part of a name or not. E.g. for
--   <tt>TyNameWithKind</tt> this flag controls whether the <tt>Kind</tt>
--   is shown or not.
[_pcnShowsAttached] :: PrettyConfigName -> Bool

-- | A class of configs from which a <a>PrettyConfigName</a> can be
--   extracted.
class HasPrettyConfigName config
toPrettyConfigName :: HasPrettyConfigName config => config -> PrettyConfigName

-- | The <a>PrettyConfigName</a> used by default: print neither
--   <a>Unique</a>s, nor name attachments.
defPrettyConfigName :: PrettyConfigName

-- | The <a>PrettyConfigName</a> used for debugging: print <a>Unique</a>s,
--   but not name attachments.
debugPrettyConfigName :: PrettyConfigName
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.PlutusCore.Name.TyName a)
instance GHC.Base.Functor Language.PlutusCore.Name.TyName
instance GHC.Classes.Ord (Language.PlutusCore.Name.TyName a)
instance GHC.Classes.Eq (Language.PlutusCore.Name.TyName a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Language.PlutusCore.Name.TyName a)
instance GHC.Generics.Generic (Language.PlutusCore.Name.TyName a)
instance GHC.Show.Show a => GHC.Show.Show (Language.PlutusCore.Name.TyName a)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Language.PlutusCore.Name.Name a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Language.PlutusCore.Name.Name a)
instance GHC.Generics.Generic (Language.PlutusCore.Name.Name a)
instance GHC.Base.Functor Language.PlutusCore.Name.Name
instance GHC.Show.Show a => GHC.Show.Show (Language.PlutusCore.Name.Name a)
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.PlutusCore.Name.Unique
instance Control.DeepSeq.NFData Language.PlutusCore.Name.Unique
instance Language.Haskell.TH.Syntax.Lift Language.PlutusCore.Name.Unique
instance GHC.Classes.Ord Language.PlutusCore.Name.Unique
instance GHC.Show.Show Language.PlutusCore.Name.Unique
instance GHC.Classes.Eq Language.PlutusCore.Name.Unique
instance Language.PlutusCore.Name.HasPrettyConfigName config => PlutusPrelude.PrettyBy config (Language.PlutusCore.Name.TyName a)
instance Language.PlutusCore.Name.HasPrettyConfigName config => PlutusPrelude.PrettyBy config (Language.PlutusCore.Name.Name a)
instance Language.PlutusCore.Name.HasUnique (Language.PlutusCore.Name.Name a) Language.PlutusCore.Name.TermUnique
instance Language.PlutusCore.Name.HasUnique (Language.PlutusCore.Name.TyName a) Language.PlutusCore.Name.TypeUnique
instance Control.Lens.Wrapped.Wrapped (Language.PlutusCore.Name.TyName a)
instance GHC.Classes.Eq (Language.PlutusCore.Name.Name a)
instance GHC.Classes.Ord (Language.PlutusCore.Name.Name a)


-- | Various views of PLC entities.
module Language.PlutusCore.View

-- | A function (called "head") applied to a list of arguments (called
--   "spine").
data IterApp head arg
IterApp :: head -> [arg] -> IterApp head arg
[_iterAppHead] :: IterApp head arg -> head
[_iterAppSpine] :: IterApp head arg -> [arg]

-- | An iterated application of a <a>Term</a> to a list of <a>Term</a>s.
type TermIterApp tyname name a = IterApp (Term tyname name a) (Term tyname name a)

-- | An iterated application of a <a>BuiltinName</a> to a list of
--   <a>Value</a>s.
type PrimIterApp tyname name a = IterApp StagedBuiltinName (Value tyname name a)

-- | View a <a>Constant</a> as an <a>Integer</a>.
constantAsInteger :: Constant a -> Maybe Integer

-- | View a <a>Constant</a> as a <a>StagedBuiltinName</a>.
constantAsStagedBuiltinName :: Builtin a -> StagedBuiltinName

-- | View a <a>Term</a> as a <a>Constant</a>.
termAsBuiltin :: Term tyname name a -> Maybe (Builtin a)

-- | An iterated application of a <a>Term</a> to a list of <a>Term</a>s.
termAsTermIterApp :: Term tyname name a -> TermIterApp tyname name a

-- | View a <a>Term</a> as an iterated application of a <a>BuiltinName</a>
--   to a list of <a>Value</a>s.
termAsPrimIterApp :: Term tyname name a -> Maybe (PrimIterApp tyname name a)

-- | Check whether a <a>Term</a> is a <a>Value</a>. The term is assumed to
--   be valid.
isTermValue :: Term tyname name a -> Bool
instance (PlutusPrelude.PrettyBy config head, PlutusPrelude.PrettyBy config arg) => PlutusPrelude.PrettyBy config (Language.PlutusCore.View.IterApp head arg)

module Language.PlutusCore.Subst

-- | Naively substitute names using the given functions (i.e. do not
--   account for scoping).
substTerm :: (tyname a -> Maybe (Type tyname a)) -> (name a -> Maybe (Term tyname name a)) -> Term tyname name a -> Term tyname name a

-- | Naively substitute names using the given function (i.e. do not account
--   for scoping).
substTy :: (tyname a -> Maybe (Type tyname a)) -> Type tyname a -> Type tyname a

-- | Get all the free term variables in a term.
fvTerm :: (Ord (name a)) => Term tyname name a -> Set (name a)

-- | Get all the free type variables in a term.
ftvTerm :: (Ord (tyname a)) => Term tyname name a -> Set (tyname a)

-- | Get all the free type variables in a type.
ftvTy :: (Ord (tyname a)) => Type tyname a -> Set (tyname a)

module Language.PlutusCore.Quote

-- | Run a quote from an empty identifier state. Note that the resulting
--   term cannot necessarily be safely combined with other terms - that
--   should happen inside <a>QuoteT</a>.
runQuoteT :: (Monad m) => QuoteT m a -> m a

-- | See <a>runQuoteT</a>.
runQuote :: Quote a -> a

-- | Get a fresh <a>Unique</a>.
freshUnique :: MonadQuote m => m Unique

-- | Get a fresh <a>Name</a>, given the annotation and the <a>Text</a>
--   name.
freshName :: Monad m => a -> Text -> QuoteT m (Name a)

-- | Get a fresh <a>TyName</a>, given the annotation and the <a>Text</a>
--   name.
freshTyName :: Monad m => a -> Text -> QuoteT m (TyName a)

-- | Make a copy of the given <a>Name</a> that is distinct from the old
--   one.
freshenName :: Monad m => Name a -> QuoteT m (Name a)

-- | Make a copy of the given <a>TyName</a> that is distinct from the old
--   one.
freshenTyName :: Monad m => TyName a -> QuoteT m (TyName a)

-- | Mark a given <a>Unique</a> (and implicitly all <a>Unique</a>s less
--   than it) as used, so they will not be generated in future.
markNonFresh :: MonadQuote m => Unique -> m ()

-- | Marks all the <a>Unique</a>s in a term as used, so they will not be
--   generated in future. Useful if you have a term which was not generated
--   in <a>Quote</a>.
markNonFreshTerm :: (HasUnique (tyname a) TypeUnique, HasUnique (name a) TermUnique, MonadQuote m) => Term tyname name a -> m ()

-- | Marks all the <a>Unique</a>s in a type as used, so they will not be
--   generated in future. Useful if you have a type which was not generated
--   in <a>Quote</a>.
markNonFreshType :: (HasUnique (tyname a) TypeUnique, MonadQuote m) => Type tyname a -> m ()

-- | Marks all the <a>Unique</a>s in a program as used, so they will not be
--   generated in future. Useful if you have a program which was not
--   generated in <a>Quote</a>.
markNonFreshProgram :: (HasUnique (tyname a) TypeUnique, HasUnique (name a) TermUnique, MonadQuote m) => Program tyname name a -> m ()

-- | The "quotation" monad transformer. Within this monad you can do safe
--   construction of PLC terms using quasiquotation, fresh-name generation,
--   and parsing.
data QuoteT m a

-- | A non-transformer version of <a>QuoteT</a>.
type Quote = QuoteT Identity

-- | A monad that allows lifting of quoted expressions.
class Monad m => MonadQuote m

-- | The state contains the "next" <a>Unique</a> that should be used for a
--   name
type FreshState = Unique
liftQuote :: MonadQuote m => Quote a -> m a
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Language.PlutusCore.Quote.QuoteT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Language.PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState Language.PlutusCore.Quote.FreshState (Language.PlutusCore.Quote.QuoteT m)
instance Control.Monad.Morph.MFunctor Language.PlutusCore.Quote.QuoteT
instance Control.Monad.Trans.Class.MonadTrans Language.PlutusCore.Quote.QuoteT
instance GHC.Base.Monad m => GHC.Base.Monad (Language.PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Language.PlutusCore.Quote.QuoteT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => Language.PlutusCore.Quote.MonadQuote (Language.PlutusCore.Quote.QuoteT m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Control.Monad.Trans.State.Lazy.StateT s m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Maybe.MaybeT m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Except.ExceptT e m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Reader.ReaderT r m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Hedgehog.Internal.Gen.GenT m)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Hedgehog.Internal.Property.PropertyT m)


-- | <tt>unit</tt> and related functions.
module Language.PlutusCore.StdLib.Data.Unit

-- | '()' as a PLC type.
--   
--   <pre>
--   all (A :: *). A -&gt; A
--   </pre>
getBuiltinUnit :: Quote (Type TyName ())

-- | '()' as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x : A) -&gt; x
--   </pre>
getBuiltinUnitval :: Quote (Value TyName Name ())

-- | <tt>seq </tt>() <tt>()</tt> as a PLC term.
--   
--   <pre>
--   \(x y : unit) -&gt; unitval
--   </pre>
getBuiltinSequ :: Quote (Value TyName Name ())


-- | <tt>sum</tt> and related functions.
module Language.PlutusCore.StdLib.Data.Sum

-- | <a>Either</a> as a PLC type.
--   
--   <pre>
--   \(a b :: *) -&gt; all (r :: *). (a -&gt; r) -&gt; (b -&gt; r) -&gt; r
--   </pre>
getBuiltinSum :: Quote (Type TyName ())

-- | <a>Left</a> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(x : a) -&gt; /\(r :: *) -&gt; \(f : a -&gt; r) -&gt; (g : b -&gt; r) -&gt; f x
--   </pre>
getBuiltinLeft :: Quote (Term TyName Name ())

-- | <a>Right</a> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(y : b) -&gt; /\(r :: *) -&gt; \(f : a -&gt; r) -&gt; (g : b -&gt; r) -&gt; g y
--   </pre>
getBuiltinRight :: Quote (Term TyName Name ())


-- | Normalization of PLC entities.
module Language.PlutusCore.Normalize

-- | The monad transformer that type normalization runs in.
data NormalizeTypeT m tyname ann a

-- | Run a <tt>NormalizeTypeM</tt> computation.
runNormalizeTypeM :: m () -> NormalizeTypeT m tyname ann a -> m a

-- | Run a <tt>NormalizeTypeM</tt> computation without dealing with gas.
runNormalizeTypeDownM :: MonadQuote m => NormalizeTypeT m tyname ann a -> m a

-- | Run a gas-consuming <tt>NormalizeTypeM</tt> computation. Count a
--   single substitution step by subtracting <tt>1</tt> from available gas
--   or fail when there is no available gas.
runNormalizeTypeGasM :: MonadQuote m => Gas -> NormalizeTypeT (StateT Gas (MaybeT m)) tyname ann a -> m (Maybe a)

-- | Locally extend a <a>TypeVarEnv</a> in a <tt>NormalizeTypeM</tt>
--   computation.
withExtendedTypeVarEnv :: (HasUnique (tyname ann) TypeUnique, Monad m) => tyname ann -> NormalizedType tyname ann -> NormalizeTypeT m tyname ann a -> NormalizeTypeT m tyname ann a

-- | Normalize a <a>Type</a> in the <tt>NormalizeTypeM</tt> monad.
normalizeTypeM :: (HasUnique (tyname ann) TypeUnique, MonadQuote m) => Type tyname ann -> NormalizeTypeT m tyname ann (NormalizedType tyname ann)
normalizeTypeDown :: (HasUnique (tyname ann) TypeUnique, MonadQuote m) => Type tyname ann -> m (NormalizedType tyname ann)

-- | Substitute a type for a variable in a type and normalize in the
--   <tt>NormalizeTypeM</tt> monad.
substituteNormalizeTypeM :: (HasUnique (tyname ann) TypeUnique, MonadQuote m) => NormalizedType tyname ann -> tyname ann -> Type tyname ann -> NormalizeTypeT m tyname ann (NormalizedType tyname ann)

-- | Normalize every <a>Type</a> in a <a>Term</a>.
normalizeTypesIn :: (HasUnique (tyname ann) TypeUnique, MonadQuote m) => Term tyname name ann -> NormalizeTypeT m tyname ann (Term tyname name ann)
instance Language.PlutusCore.Quote.MonadQuote m => Language.PlutusCore.Quote.MonadQuote (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Language.PlutusCore.Normalize.NormalizeTypeEnv m tyname ann) (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Monad m => GHC.Base.Monad (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.PlutusCore.Normalize.NormalizeTypeT m tyname ann)

module Language.PlutusCore.MkPlc

-- | A "variable declaration", i.e. a name and a type for a variable.
data VarDecl tyname name a
VarDecl :: a -> name a -> Type tyname a -> VarDecl tyname name a
[varDeclAnn] :: VarDecl tyname name a -> a
[varDeclName] :: VarDecl tyname name a -> name a
[varDeclType] :: VarDecl tyname name a -> Type tyname a

-- | A "type variable declaration", i.e. a name and a kind for a type
--   variable.
data TyVarDecl tyname a
TyVarDecl :: a -> tyname a -> Kind a -> TyVarDecl tyname a
[tyVarDeclAnn] :: TyVarDecl tyname a -> a
[tyVarDeclName] :: TyVarDecl tyname a -> tyname a
[tyVarDeclKind] :: TyVarDecl tyname a -> Kind a

-- | A "type declaration", i.e. a kind for a type.
data TyDecl tyname a
TyDecl :: a -> Type tyname a -> Kind a -> TyDecl tyname a
[tyDeclAnn] :: TyDecl tyname a -> a
[tyDeclType] :: TyDecl tyname a -> Type tyname a
[tyDeclKind] :: TyDecl tyname a -> Kind a

-- | Make a <a>Var</a> referencing the given <a>VarDecl</a>.
mkVar :: a -> VarDecl tyname name a -> Term tyname name a

-- | Make a <a>TyVar</a> referencing the given <a>TyVarDecl</a>.
mkTyVar :: a -> TyVarDecl tyname a -> Type tyname a
tyDeclVar :: TyVarDecl tyname a -> TyDecl tyname a

-- | A definition. Pretty much just a pair with more descriptive names.
data Def var val
Def :: var -> val -> Def var val
[defVar] :: Def var val -> var
[defVal] :: Def var val -> val

-- | A term definition as a variable.
type TermDef tyname name a = Def (VarDecl tyname name a) (Term tyname name a)

-- | A type definition as a type variable.
type TypeDef tyname a = Def (TyVarDecl tyname a) (Type tyname a)

-- | The type of a PLC function.
data FunctionType tyname ann
FunctionType :: ann -> Type tyname ann -> Type tyname ann -> FunctionType tyname ann

-- | An annotation.
[_functionTypeAnn] :: FunctionType tyname ann -> ann

-- | The domain of a function.
[_functionTypeDom] :: FunctionType tyname ann -> Type tyname ann

-- | The codomain of the function.
[_functionTypeCod] :: FunctionType tyname ann -> Type tyname ann

-- | A PLC function.
data FunctionDef tyname name ann
FunctionDef :: ann -> name ann -> FunctionType tyname ann -> Term tyname name ann -> FunctionDef tyname name ann

-- | An annotation.
[_functionDefAnn] :: FunctionDef tyname name ann -> ann

-- | The name of a function.
[_functionDefName] :: FunctionDef tyname name ann -> name ann

-- | The type of the function.
[_functionDefType] :: FunctionDef tyname name ann -> FunctionType tyname ann

-- | The definition of the function.
[_functionDefTerm] :: FunctionDef tyname name ann -> Term tyname name ann

-- | Convert a <a>FunctionType</a> to the corresponding <a>Type</a>.
functionTypeToType :: FunctionType tyname ann -> Type tyname ann

-- | Get the type of a <a>FunctionDef</a>.
functionDefToType :: FunctionDef tyname name ann -> Type tyname ann

-- | Convert a <a>FunctionDef</a> to a <a>VarDecl</a>. I.e. ignore the
--   actual term.
functionDefVarDecl :: FunctionDef tyname name ann -> VarDecl tyname name ann

-- | Make a <tt>FunctioDef</tt>. Return <a>Nothing</a> if the provided type
--   is not functional.
mkFunctionDef :: ann -> name ann -> Type tyname ann -> Term tyname name ann -> Maybe (FunctionDef tyname name ann)

-- | Make a "let-binding" for a term.
mkTermLet :: a -> TermDef tyname name a -> Term tyname name a -> Term tyname name a

-- | Make a "let-binding" for a type. Note: the body must be a value.
mkTypeLet :: a -> TypeDef tyname a -> Term tyname name a -> Term tyname name a

-- | Universally quantify a list of names.
mkIterTyForall :: [TyVarDecl tyname a] -> Type tyname a -> Type tyname a

-- | Lambda abstract a list of names.
mkIterTyLam :: [TyVarDecl tyname a] -> Type tyname a -> Type tyname a

-- | Make an iterated application.
mkIterApp :: a -> Term tyname name a -> [Term tyname name a] -> Term tyname name a

-- | Make an iterated function type.
mkIterTyFun :: a -> [Type tyname a] -> Type tyname a -> Type tyname a

-- | Lambda abstract a list of names.
mkIterLamAbs :: [VarDecl tyname name a] -> Term tyname name a -> Term tyname name a

-- | Make an iterated instantiation.
mkIterInst :: a -> Term tyname name a -> [Type tyname a] -> Term tyname name a

-- | Type abstract a list of names.
mkIterTyAbs :: [TyVarDecl tyname a] -> Term tyname name a -> Term tyname name a

-- | Make an iterated type application.
mkIterTyApp :: a -> Type tyname a -> [Type tyname a] -> Type tyname a

-- | Make an iterated function kind.
mkIterKindArrow :: a -> [Kind a] -> Kind a -> Kind a
instance GHC.Generics.Generic (Language.PlutusCore.MkPlc.Def var val)
instance (GHC.Classes.Ord var, GHC.Classes.Ord val) => GHC.Classes.Ord (Language.PlutusCore.MkPlc.Def var val)
instance (GHC.Classes.Eq var, GHC.Classes.Eq val) => GHC.Classes.Eq (Language.PlutusCore.MkPlc.Def var val)
instance (GHC.Show.Show var, GHC.Show.Show val) => GHC.Show.Show (Language.PlutusCore.MkPlc.Def var val)
instance GHC.Generics.Generic (Language.PlutusCore.MkPlc.TyDecl tyname a)
instance (GHC.Classes.Ord (tyname a), GHC.Classes.Eq a) => GHC.Classes.Eq (Language.PlutusCore.MkPlc.TyDecl tyname a)
instance (GHC.Show.Show a, GHC.Show.Show (tyname a)) => GHC.Show.Show (Language.PlutusCore.MkPlc.TyDecl tyname a)
instance GHC.Base.Functor tyname => GHC.Base.Functor (Language.PlutusCore.MkPlc.TyDecl tyname)
instance GHC.Generics.Generic (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (tyname a)) => GHC.Classes.Eq (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance (GHC.Show.Show a, GHC.Show.Show (tyname a)) => GHC.Show.Show (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance GHC.Base.Functor tyname => GHC.Base.Functor (Language.PlutusCore.MkPlc.TyVarDecl tyname)
instance GHC.Generics.Generic (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance (GHC.Classes.Ord (tyname a), GHC.Classes.Eq a, GHC.Classes.Eq (name a)) => GHC.Classes.Eq (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance (GHC.Show.Show a, GHC.Show.Show (name a), GHC.Show.Show (tyname a)) => GHC.Show.Show (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance (GHC.Base.Functor name, GHC.Base.Functor tyname) => GHC.Base.Functor (Language.PlutusCore.MkPlc.VarDecl tyname name)


-- | <tt>tuple</tt>s of various sizees and related functions.
module Language.PlutusCore.StdLib.Meta.Data.Tuple

-- | A Plutus Core tuple.
data Tuple ann
Tuple :: [Type TyName ann] -> Term TyName Name ann -> Tuple ann

-- | The types of elements of a tuple.
[_tupleElementTypes] :: Tuple ann -> [Type TyName ann]

-- | A term representation of the tuple.
[_tupleTerm] :: Tuple ann -> Term TyName Name ann

-- | Get the type of a <a>Tuple</a>.
--   
--   <pre>
--   getTupleType _ (Tuple [a1, ... , an] _) = all r. (a1 -&gt; ... -&gt; an -&gt; r) -&gt; r
--   </pre>
getTupleType :: MonadQuote m => ann -> Tuple ann -> m (Type TyName ann)

-- | Get the type of the ith element of a <a>Tuple</a> along with the
--   element itself.
--   
--   <pre>
--   tupleTypeTermAt _ i (Tuple [a0, ... , an] term) =
--       (ai, term {ai} (\(x0 : a0) ... (xn : an) -&gt; xi))
--   </pre>
tupleTypeTermAt :: MonadQuote m => ann -> Int -> Tuple ann -> m (Type TyName ann, Term TyName Name ann)

-- | Get the ith element of a <a>Tuple</a>.
tupleTermAt :: MonadQuote m => ann -> Int -> Tuple ann -> m (Term TyName Name ann)

-- | Get the ith element of a <a>Tuple</a> as a <a>TermDef</a>.
tupleDefAt :: MonadQuote m => ann -> Int -> Name ann -> Tuple ann -> m (TermDef TyName Name ann)

-- | Bind all elements of a <a>Tuple</a> inside a <a>Term</a>.
--   
--   <pre>
--   bindTuple _ [x_1, ... , x_n] (Tuple [a1, ... , an] term) body =
--       (\(tup : all r. (a_1 -&gt; ... -&gt; a_n -&gt; r) -&gt; r) -&gt;
--         let x_1 = _1 tup
--             ...
--             x_n = _n tup
--           in body
--       ) term
--   </pre>
bindTuple :: MonadQuote m => ann -> [Name ann] -> Tuple ann -> Term TyName Name ann -> m (Term TyName Name ann)

-- | Given an arity <tt>n</tt>, create the n-ary product type.
--   
--   <pre>
--   (T_1 :: *) .. (T_n :: *) . all (R :: *) . (T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; R
--   </pre>
getBuiltinProdN :: MonadQuote m => Int -> m (Type TyName ())

-- | Given an arity <tt>n</tt>, create the constructor for n-ary products.
--   
--   <pre>
--   /(T_1 :: *) .. (T_n :: *) .
--       (arg_1 : T_1) .. (arg_n : T_n) .
--           /(R :: *).
--               (case : T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; case arg_1 .. arg_n
--   </pre>
getBuiltinProdNConstructor :: MonadQuote m => Int -> m (Term TyName Name ())

-- | Given an arity <tt>n</tt> and an index <tt>i</tt>, create a function
--   for accessing the i'th component of a n-tuple.
--   
--   <pre>
--   /(T_1 :: *) .. (T_n :: *) .
--       (tuple : all (R :: *) . (T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; R)) .
--           tuple {T_i} ((arg_1 : T_1) .. (arg_n : T_n) . arg_i)
--   </pre>
getBuiltinProdNAccessor :: MonadQuote m => Int -> Int -> m (Term TyName Name ())

-- | Convert a Haskell spine of <a>Term</a>s to a PLC <a>Tuple</a>.
--   
--   <pre>
--   getSpineToTuple _ [(a1, x1), ... , (an, xn)] =
--       Tuple [a1, ... , an] (/\(r :: *) -&gt; \(f :: a1 -&gt; ... -&gt; an -&gt; r) -&gt; f x1 ... xn)
--   </pre>
getSpineToTuple :: MonadQuote m => ann -> [(Type TyName ann, Term TyName Name ann)] -> m (Tuple ann)


-- | Church-encoded <tt>nat</tt> and related functions.
module Language.PlutusCore.StdLib.Data.ChurchNat

-- | Church-encoded <tt>Nat</tt> as a PLC type.
--   
--   <pre>
--   all (r :: *). r -&gt; (r -&gt; r) -&gt; r
--   </pre>
getBuiltinChurchNat :: Quote (Type TyName ())

-- | Church-encoded '0' as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(z : r) (f : r -&gt; r) -&gt; z
--   </pre>
getBuiltinChurchZero :: Quote (Term TyName Name ())

-- | Church-encoded <a>succ</a> as a PLC term.
--   
--   <pre>
--   \(n : nat) -&gt; /\(r :: *) -&gt; \(z : r) (f : r -&gt; r) -&gt; f (n {r} z f)
--   </pre>
getBuiltinChurchSucc :: Quote (Term TyName Name ())


-- | <tt>boolean</tt> and related functions.
module Language.PlutusCore.StdLib.Data.Bool

-- | <a>Bool</a> as a PLC type.
--   
--   <pre>
--   all (A :: *). A -&gt; A -&gt; A
--   </pre>
getBuiltinBool :: Quote (Type TyName ())

-- | <a>True</a> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x y : A) -&gt; x
--   </pre>
getBuiltinTrue :: Quote (Value TyName Name ())

-- | <a>False</a> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x y : A) -&gt; y
--   </pre>
getBuiltinFalse :: Quote (Value TyName Name ())

-- | <tt>if_then_else_</tt> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(b : Bool) (x y : () -&gt; A) -&gt; b {() -&gt; A} x y ()
--   </pre>
getBuiltinIf :: Quote (Value TyName Name ())


-- | Machinery defined in this module allows to export mulptiple Plutus
--   Core definitions (types and terms) as a single value which enables
--   convenient testing of various procedures (pretty-printing, type
--   checking, etc): each time a function / data type is added to that
--   value, none of the tests is required to be adapted, instead all the
--   tests see the new definition automatically.
module Language.PlutusCore.FsTree

-- | An <a>FsTree</a> is either a file or a folder with a list of
--   <a>FsTree</a>s inside.
data FsTree a
FsFolder :: String -> (FolderContents a) -> FsTree a
FsFile :: String -> a -> FsTree a

-- | The contents of a folder. A wrapper around <tt>[FsTree a]</tt>. Exists
--   because of its <a>Semigroup</a> instance which allows to concatenate
--   two <a>FolderContents</a>s without placing them into the same folder
--   immediately, so we can have various PLC "modules" (<tt>stdlib</tt>,
--   <tt>examples</tt>, etc), define compound modules (e.g. <tt>stdlib
--   &lt;&gt; examples</tt>) and run various tests (pretty-printing, type
--   synthesis, etc) against simple and compound modules uniformly.
newtype FolderContents a
FolderContents :: [FsTree a] -> FolderContents a
[unFolderContents] :: FolderContents a -> [FsTree a]

-- | A <a>PlcEntity</a> is either a <a>Type</a> or a <a>Term</a>.
data PlcEntity
PlcType :: (Quote (Type TyName ())) -> PlcEntity
PlcTerm :: (Quote (Term TyName Name ())) -> PlcEntity
type PlcFsTree = FsTree PlcEntity
type PlcFolderContents = FolderContents PlcEntity

-- | Construct an <a>FsTree</a> out of the name of a folder and a list of
--   <a>FsTree</a>s.
treeFolderContents :: String -> [FsTree a] -> FsTree a

-- | Construct a single-file <a>PlcFsTree</a> out of a type.
plcTypeFile :: String -> Quote (Type TyName ()) -> PlcFsTree

-- | Construct a single-file <a>PlcFsTree</a> out of a term.
plcTermFile :: String -> Quote (Term TyName Name ()) -> PlcFsTree

-- | Fold a <a>FsTree</a>.
foldFsTree :: (String -> [b] -> b) -> (String -> a -> b) -> FsTree a -> b

-- | Fold a <a>PlcFsTree</a>.
foldPlcFsTree :: (String -> [b] -> b) -> (String -> Quote (Type TyName ()) -> b) -> (String -> Quote (Term TyName Name ()) -> b) -> PlcFsTree -> b

-- | Fold the contents of a PLC folder.
foldPlcFolderContents :: (String -> [b] -> b) -> (String -> Quote (Type TyName ()) -> b) -> (String -> Quote (Term TyName Name ()) -> b) -> PlcFolderContents -> [b]
instance GHC.Base.Monoid (Language.PlutusCore.FsTree.FolderContents a)
instance GHC.Base.Semigroup (Language.PlutusCore.FsTree.FolderContents a)

module Language.PlutusCore.Pretty
data Doc ann
class Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann

-- | Overloaded configurable conversion to <a>Doc</a>. I.e. like
--   <a>Pretty</a>, but parameterized by a <tt>config</tt>. This class is
--   interoperable with the <a>Pretty</a> class via
--   <a>PrettyConfigIgnore</a> and <tt>PrettyConfigAttatch</tt>.
class PrettyBy config a
prettyBy :: PrettyBy config a => config -> a -> Doc ann
prettyBy :: (PrettyBy config a, DefaultPrettyBy config a) => config -> a -> Doc ann

-- | A newtype wrapper around <tt>a</tt> which point is to provide a
--   'PrettyBy config' instance for anything that has a <a>Pretty</a>
--   instance.
newtype PrettyConfigIgnore a
PrettyConfigIgnore :: a -> PrettyConfigIgnore a
[unPrettyConfigIgnore] :: PrettyConfigIgnore a -> a

-- | A config together with some value. The point is to provide a
--   <a>Pretty</a> instance for anything that has a 'PrettyBy config'
--   instance.
data PrettyConfigAttach config a
PrettyConfigAttach :: config -> a -> PrettyConfigAttach config a

-- | Render a <a>Doc</a> as <a>String</a>.
docString :: Doc a -> String

-- | Render a <a>Doc</a> as <tt>Text</tt>.
docText :: Doc a -> Text

-- | Render a value as <a>String</a>.
prettyString :: Pretty a => a -> String

-- | Render a value as strict <tt>Text</tt>.
prettyText :: Pretty a => a -> Text

-- | Render a value as <a>String</a>.
prettyStringBy :: PrettyBy config a => config -> a -> String

-- | Render a value as strict <tt>Text</tt>.
prettyTextBy :: PrettyBy config a => config -> a -> Text

-- | Pretty-print a value in the default mode using the classic view.
prettyPlcDef :: PrettyPlc a => a -> Doc ann

-- | Render a value to <a>String</a> in the default mode using the classic
--   view.
prettyPlcDefString :: PrettyPlc a => a -> String

-- | Render a value to <a>Text</a> in the default mode using the classic
--   view.
prettyPlcDefText :: PrettyPlc a => a -> Text

-- | Whether to pretty-print PLC errors in full or with some information
--   omitted.
data CondensedErrors
CondensedErrorsYes :: CondensedErrors
CondensedErrorsNo :: CondensedErrors

-- | Options for pretty-printing PLC entities.
newtype PrettyConfigPlcOptions
PrettyConfigPlcOptions :: CondensedErrors -> PrettyConfigPlcOptions
[_pcpoCondensedErrors] :: PrettyConfigPlcOptions -> CondensedErrors

-- | Strategy for pretty-printing PLC entities.
data PrettyConfigPlcStrategy
PrettyConfigPlcClassic :: (PrettyConfigClassic PrettyConfigName) -> PrettyConfigPlcStrategy
PrettyConfigPlcReadable :: (PrettyConfigReadable PrettyConfigName) -> PrettyConfigPlcStrategy

-- | Global configuration used for pretty-printing PLC entities.
data PrettyConfigPlc
PrettyConfigPlc :: PrettyConfigPlcOptions -> PrettyConfigPlcStrategy -> PrettyConfigPlc
[_pcpOptions] :: PrettyConfigPlc -> PrettyConfigPlcOptions
[_pcpStrategy] :: PrettyConfigPlc -> PrettyConfigPlcStrategy

-- | The "pretty-printable PLC entity" constraint.
type PrettyPlc = PrettyBy PrettyConfigPlc

-- | The <a>PrettyConfigPlcOptions</a> used by default: print errors in
--   full.
defPrettyConfigPlcOptions :: PrettyConfigPlcOptions

-- | The <a>PrettyConfigPlc</a> used by default: use the classic view and
--   print neither <a>Unique</a>s, nor name attachments.
defPrettyConfigPlcClassic :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used for debugging: use the classic view
--   and print <a>Unique</a>s, but not name attachments.
debugPrettyConfigPlcClassic :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used by default and for readability: use
--   the refined view and print neither <a>Unique</a>s, nor name
--   attachments.
defPrettyConfigPlcReadable :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used for debugging and readability: use the
--   refined view and print <a>Unique</a>s, but not name attachments.
debugPrettyConfigPlcReadable :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | Pretty-print a PLC value in the default mode using the classic view.
prettyPlcClassicDef :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the debug mode using the classic view.
prettyPlcClassicDebug :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the default mode using the readable view.
prettyPlcReadableDef :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the debug mode using the readable view.
prettyPlcReadableDebug :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value using the condensed way (see
--   <a>CondensedErrors</a>) of pretty-printing PLC errors (in case there
--   are any).
prettyPlcCondensedErrorBy :: PrettyPlc a => (PrettyConfigPlcOptions -> PrettyConfigPlc) -> a -> Doc ann

-- | Render an error to <a>String</a> in the condensed manner using the
--   classic view.
prettyPlcCondensedErrorClassicString :: PrettyPlc a => a -> String

-- | A config that determines how to pretty-print a PLC name.
data PrettyConfigName
PrettyConfigName :: Bool -> Bool -> PrettyConfigName

-- | Whether to show the <a>Unique</a> of a <a>Name</a> or not.
[_pcnShowsUnique] :: PrettyConfigName -> Bool

-- | Whether to show the "With" part of a name or not. E.g. for
--   <tt>TyNameWithKind</tt> this flag controls whether the <tt>Kind</tt>
--   is shown or not.
[_pcnShowsAttached] :: PrettyConfigName -> Bool

-- | A class of configs from which a <a>PrettyConfigName</a> can be
--   extracted.
class HasPrettyConfigName config
toPrettyConfigName :: HasPrettyConfigName config => config -> PrettyConfigName

-- | The <a>PrettyConfigName</a> used by default: print neither
--   <a>Unique</a>s, nor name attachments.
defPrettyConfigName :: PrettyConfigName

-- | The <a>PrettyConfigName</a> used for debugging: print <a>Unique</a>s,
--   but not name attachments.
debugPrettyConfigName :: PrettyConfigName

-- | Configuration for the classic pretty-printing.
newtype PrettyConfigClassic configName
PrettyConfigClassic :: configName -> PrettyConfigClassic configName
[_pccConfigName] :: PrettyConfigClassic configName -> configName

-- | The "classically pretty-printable" constraint.
type PrettyClassicBy configName = PrettyBy (PrettyConfigClassic configName)
type PrettyClassic = PrettyClassicBy PrettyConfigName

-- | Pretty-print a value in the default mode using the classic view.
prettyClassicDef :: PrettyClassic a => a -> Doc ann

-- | A context an expression is rendering in.
data RenderContext
RenderContext :: Fixity -> Direction -> RenderContext
[_rcFixity] :: RenderContext -> Fixity
[_rcDirection] :: RenderContext -> Direction
data ShowKinds
ShowKindsYes :: ShowKinds
ShowKindsNo :: ShowKinds

-- | Configuration for the readable pretty-printing.
data PrettyConfigReadable configName
PrettyConfigReadable :: configName -> RenderContext -> ShowKinds -> PrettyConfigReadable configName
[_pcrConfigName] :: PrettyConfigReadable configName -> configName
[_pcrRenderContext] :: PrettyConfigReadable configName -> RenderContext
[_pcrShowKinds] :: PrettyConfigReadable configName -> ShowKinds

-- | The "readably pretty-printable" constraint.
type PrettyReadableBy configName = PrettyBy (PrettyConfigReadable configName)
type PrettyReadable = PrettyReadableBy PrettyConfigName

-- | A <a>PrettyConfigReadable</a> with the fixity specified to
--   <a>topApp</a>.
topPrettyConfigReadable :: configName -> ShowKinds -> PrettyConfigReadable configName

-- | A <a>PrettyConfigReadable</a> with the fixity specified to
--   <a>botApp</a>.
botPrettyConfigReadable :: configName -> ShowKinds -> PrettyConfigReadable configName
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Kind a)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Constant a)
instance Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Builtin a)
instance Language.PlutusCore.Pretty.Classic.PrettyClassic (Language.PlutusCore.Type.Type tyname a) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Type tyname a)
instance Language.PlutusCore.Pretty.Classic.PrettyClassic (Language.PlutusCore.Type.Term tyname name a) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Term tyname name a)
instance Language.PlutusCore.Pretty.Classic.PrettyClassic (Language.PlutusCore.Type.Program tyname name a) => Data.Text.Prettyprint.Doc.Internal.Pretty (Language.PlutusCore.Type.Program tyname name a)


-- | This module defines Haskell data types that simplify construction of
--   PLC types and terms.
module Language.PlutusCore.StdLib.Type

-- | A recursive type packaged along with a specified <tt>Wrap</tt> that
--   allows to construct elements of this type.
data RecursiveType ann
RecursiveType :: Type TyName ann -> [Type TyName ann] -> Term TyName Name ann -> Term TyName Name ann -> RecursiveType ann
[_recursiveType] :: RecursiveType ann -> Type TyName ann
[_recursiveWrap] :: RecursiveType ann -> [Type TyName ann] -> Term TyName Name ann -> Term TyName Name ann

-- | Construct a <a>RecursiveType</a> by encoding an n-ary pattern functor
--   as the corresponding 1-ary one and passing it to <a>TyIFix</a> and
--   <a>IWrap</a>. <tt>n</tt> type arguments get packaged together as a
--   CPS-encoded spine.
makeRecursiveType :: FromDataPieces ann (RecursiveType ann)
instance GHC.Show.Show Language.PlutusCore.StdLib.Type.IndicesLengthsMismatchException
instance GHC.Exception.Exception Language.PlutusCore.StdLib.Type.IndicesLengthsMismatchException


-- | Combinators.
module Language.PlutusCore.StdLib.Data.Function

-- | <a>const</a> as a PLC term.
--   
--   <pre>
--   /\ (A B :: *) -&gt; \(x : A) (y : B) -&gt; x
--   </pre>
getBuiltinConst :: Quote (Term TyName Name ())

-- | <tt>Self</tt> as a PLC type.
--   
--   <pre>
--   fix \(self :: * -&gt; *) (a :: *) -&gt; self a -&gt; a
--   </pre>
getBuiltinSelf :: Quote (RecursiveType ())

-- | <tt>unroll</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(s : self a) -&gt; unwrap s s
--   </pre>
getBuiltinUnroll :: Quote (Term TyName Name ())

-- | <tt>fix</tt> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(f : (a -&gt; b) -&gt; a -&gt; b) -&gt;
--      unroll {a -&gt; b} (iwrap selfF (a -&gt; b) \(s : self (a -&gt; b)) \(x : a) -&gt; f (unroll {a -&gt; b} s) x)
--   </pre>
--   
--   See <tt>plutus<i>docs</i>fomega/z-combinator-benchmarks</tt> for
--   details.
getBuiltinFix :: Quote (Term TyName Name ())

-- | Make a <tt>n</tt>-ary fixpoint combinator.
--   
--   <pre>
--   getBuiltinFixN n :
--       forall A1 B1 ... An Bn :: * .
--       (forall Q :: * .
--           ((A1 -&gt; B1) -&gt; ... -&gt; (An -&gt; Bn) -&gt; Q) -&gt;
--           (A1 -&gt; B1) -&gt;
--           ... -&gt;
--           (An -&gt; Bn) -&gt;
--           Q) -&gt;
--       (forall R :: * . ((A1 -&gt; B1) -&gt; ... (An -&gt; Bn) -&gt; R) -&gt; R)
--   </pre>
getBuiltinFixN :: Int -> Quote (Term TyName Name ())

-- | A PLC function.
data FunctionDef tyname name ann
FunctionDef :: ann -> name ann -> FunctionType tyname ann -> Term tyname name ann -> FunctionDef tyname name ann

-- | An annotation.
[_functionDefAnn] :: FunctionDef tyname name ann -> ann

-- | The name of a function.
[_functionDefName] :: FunctionDef tyname name ann -> name ann

-- | The type of the function.
[_functionDefType] :: FunctionDef tyname name ann -> FunctionType tyname ann

-- | The definition of the function.
[_functionDefTerm] :: FunctionDef tyname name ann -> Term tyname name ann

-- | Get the fixed-point of a list of mutually recursive functions.
--   
--   <pre>
--   getBuiltinMutualFixOf _ [ FunctionDef _ fN1 (FunctionType _ a1 b1) f1
--                           , ...
--                           , FunctionDef _ fNn (FunctionType _ an bn) fn
--                           ] =
--       Tuple [(a1 -&gt; b1) ... (an -&gt; bn)] $
--           fixN {a1} {b1} ... {an} {bn}
--               /\(q :: *) -&gt; \(choose : (a1 -&gt; b1) -&gt; ... -&gt; (an -&gt; bn) -&gt; q) -&gt;
--                   \(fN1 : a1 -&gt; b1) ... (fNn : an -&gt; bn) -&gt; choose f1 ... fn
--   </pre>
getBuiltinMutualFixOf :: ann -> [FunctionDef TyName Name ann] -> Quote (Tuple ann)


-- | This module exports all available examples via a data type which
--   allows to test various procedures (pretty-printing, type checking,
--   etc) over the entire set of examples in a convenient way: each time a
--   function / data type is added to examples, none of the tests is
--   required to be adapted, instead you just add the new definition to
--   <a>examples</a> defined below and all the tests see it automatically.
module Language.PlutusCore.Examples.Everything

-- | All examples exported as a single value.
examples :: PlcFolderContents


-- | This module defines a common type various evaluation machine use to
--   return their results.
module Language.PlutusCore.Evaluation.Result

-- | The parameterized type of results various evaluation engines return.
data EvaluationResultF a
EvaluationSuccess :: a -> EvaluationResultF a
EvaluationFailure :: EvaluationResultF a

-- | The type of results various evaluation engines return.
type EvaluationResult = EvaluationResultF (Value TyName Name ())

-- | Map <a>EvaluationSuccess</a> to <a>Just</a> and
--   <a>EvaluationFailure</a> to <a>Nothing</a>.
evaluationResultToMaybe :: EvaluationResult -> Maybe (Value TyName Name ())

-- | Map <a>Just</a> to <a>EvaluationSuccess</a> and <a>Nothing</a> to
--   <a>EvaluationFailure</a>.
maybeToEvaluationResult :: Maybe (Value TyName Name ()) -> EvaluationResult
instance Data.Traversable.Traversable Language.PlutusCore.Evaluation.Result.EvaluationResultF
instance Data.Foldable.Foldable Language.PlutusCore.Evaluation.Result.EvaluationResultF
instance GHC.Base.Functor Language.PlutusCore.Evaluation.Result.EvaluationResultF
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.PlutusCore.Evaluation.Result.EvaluationResultF a)
instance GHC.Show.Show a => GHC.Show.Show (Language.PlutusCore.Evaluation.Result.EvaluationResultF a)
instance PlutusPrelude.PrettyBy config (Language.PlutusCore.Type.Value Language.PlutusCore.Name.TyName Language.PlutusCore.Name.Name ()) => PlutusPrelude.PrettyBy config Language.PlutusCore.Evaluation.Result.EvaluationResult
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Applicative Language.PlutusCore.Evaluation.Result.EvaluationResultF
instance GHC.Base.Monad Language.PlutusCore.Evaluation.Result.EvaluationResultF


-- | Support for using de Bruijn indices for term and type names.
module Language.PlutusCore.DeBruijn

-- | A relative index used for de Bruijn identifiers.
newtype Index
Index :: Natural -> Index

-- | A term name as a de Bruijn index.
data DeBruijn a
DeBruijn :: a -> Text -> Index -> DeBruijn a
[dbnAttribute] :: DeBruijn a -> a
[dbnString] :: DeBruijn a -> Text
[dbnIndex] :: DeBruijn a -> Index

-- | A type name as a de Bruijn index.
newtype TyDeBruijn a
TyDeBruijn :: (DeBruijn a) -> TyDeBruijn a

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: Unique -> FreeVariableError
FreeIndex :: Index -> FreeVariableError

-- | Convert a <a>Type</a> with <a>TyName</a>s into a <a>Type</a> with
--   <a>TyDeBruijn</a>s.
deBruijnTy :: (MonadError FreeVariableError m) => Type TyName a -> m (Type TyDeBruijn a)

-- | Convert a <a>Term</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Term</a> with <a>TyDeBruijn</a>s and <a>DeBruijn</a>s.
deBruijnTerm :: (MonadError FreeVariableError m) => Term TyName Name a -> m (Term TyDeBruijn DeBruijn a)

-- | Convert a <a>Program</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Program</a> with <a>TyDeBruijn</a>s and <a>DeBruijn</a>s.
deBruijnProgram :: (MonadError FreeVariableError m) => Program TyName Name a -> m (Program TyDeBruijn DeBruijn a)

-- | Convert a <a>Type</a> with <a>TyDeBruijn</a>s into a <a>Type</a> with
--   <a>TyName</a>s.
unDeBruijnTy :: (MonadQuote m, MonadError FreeVariableError m) => Type TyDeBruijn a -> m (Type TyName a)

-- | Convert a <a>Term</a> with <a>TyDeBruijn</a>s and <a>DeBruijn</a>s
--   into a <a>Term</a> with <a>TyName</a>s and <a>Name</a>s.
unDeBruijnTerm :: (MonadQuote m, MonadError FreeVariableError m) => Term TyDeBruijn DeBruijn a -> m (Term TyName Name a)

-- | Convert a <a>Program</a> with <a>TyDeBruijn</a>s and <a>DeBruijn</a>s
--   into a <a>Program</a> with <a>TyName</a>s and <a>Name</a>s.
unDeBruijnProgram :: (MonadQuote m, MonadError FreeVariableError m) => Program TyDeBruijn DeBruijn a -> m (Program TyName Name a)
instance GHC.Classes.Ord Language.PlutusCore.DeBruijn.FreeVariableError
instance GHC.Classes.Eq Language.PlutusCore.DeBruijn.FreeVariableError
instance GHC.Show.Show Language.PlutusCore.DeBruijn.FreeVariableError
instance GHC.Num.Num Language.PlutusCore.DeBruijn.Level
instance GHC.Classes.Ord Language.PlutusCore.DeBruijn.Level
instance GHC.Classes.Eq Language.PlutusCore.DeBruijn.Level
instance GHC.Generics.Generic (Language.PlutusCore.DeBruijn.TyDeBruijn a)
instance GHC.Base.Functor Language.PlutusCore.DeBruijn.TyDeBruijn
instance GHC.Show.Show a => GHC.Show.Show (Language.PlutusCore.DeBruijn.TyDeBruijn a)
instance GHC.Generics.Generic (Language.PlutusCore.DeBruijn.DeBruijn a)
instance GHC.Base.Functor Language.PlutusCore.DeBruijn.DeBruijn
instance GHC.Show.Show a => GHC.Show.Show (Language.PlutusCore.DeBruijn.DeBruijn a)
instance GHC.Classes.Ord Language.PlutusCore.DeBruijn.Index
instance GHC.Classes.Eq Language.PlutusCore.DeBruijn.Index
instance GHC.Num.Num Language.PlutusCore.DeBruijn.Index
instance GHC.Show.Show Language.PlutusCore.DeBruijn.Index
instance GHC.Generics.Generic Language.PlutusCore.DeBruijn.Index
instance Language.PlutusCore.Name.HasPrettyConfigName config => PlutusPrelude.PrettyBy config (Language.PlutusCore.DeBruijn.TyDeBruijn a)
instance GHC.Exception.Exception Language.PlutusCore.DeBruijn.FreeVariableError
instance Language.PlutusCore.DeBruijn.HasIndex (Language.PlutusCore.DeBruijn.DeBruijn a)
instance Language.PlutusCore.DeBruijn.HasIndex (Language.PlutusCore.DeBruijn.TyDeBruijn a)
instance Control.Lens.Wrapped.Wrapped (Language.PlutusCore.DeBruijn.TyDeBruijn a)
instance Language.PlutusCore.Name.HasPrettyConfigName config => PlutusPrelude.PrettyBy config (Language.PlutusCore.DeBruijn.DeBruijn a)

module Common

-- | A <a>TestTree</a> of tests under some name prefix.
type TestNested = Reader [String] TestTree

-- | Run a <a>TestTree</a> of tests with a given name prefix.
runTestNestedIn :: [String] -> TestNested -> TestTree

-- | Run a <a>TestTree</a> of tests with an empty prefix.
runTestNested :: TestNested -> TestTree

-- | Descend into a name prefix.
testNested :: String -> [TestNested] -> TestNested

-- | Check the contents of a file against a <a>Text</a>.
goldenVsText :: TestName -> FilePath -> Text -> TestTree

-- | Check the contents of a file against a <a>Text</a>.
goldenVsTextM :: TestName -> FilePath -> IO Text -> TestTree

-- | Check the contents of a file against a <a>Doc</a>.
goldenVsDoc :: TestName -> FilePath -> Doc ann -> TestTree

-- | Check the contents of a file against a <a>Doc</a>.
goldenVsDocM :: TestName -> FilePath -> IO (Doc ann) -> TestTree

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsText :: TestName -> Text -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsTextM :: TestName -> IO Text -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsDoc :: TestName -> Doc ann -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsDocM :: TestName -> IO (Doc ann) -> TestNested


-- | The value restriction check.
module Language.PlutusCore.Check.ValueRestriction

-- | Check whether a term satisfies the value restriction.
checkTerm :: (AsValueRestrictionError e tyname ann, MonadError e m) => Term tyname name ann -> m ()

-- | Check whether a program satisfies the value restriction.
checkProgram :: (AsValueRestrictionError e tyname ann, MonadError e m) => Program tyname name ann -> m ()

module Language.PlutusCore.Check.Uniques
checkProgram :: (Ord a, HasUnique (name a) TermUnique, HasUnique (tyname a) TypeUnique, AsUniqueError e a, MonadError e m) => (UniqueError a -> Bool) -> Program tyname name a -> m ()
checkTerm :: (Ord a, HasUnique (name a) TermUnique, HasUnique (tyname a) TypeUnique, AsUniqueError e a, MonadError e m) => (UniqueError a -> Bool) -> Term tyname name a -> m ()
checkType :: (Ord a, HasUnique (tyname a) TypeUnique, AsUniqueError e a, MonadError e m) => (UniqueError a -> Bool) -> Type tyname a -> m ()


-- | <tt>nat</tt> and related functions.
module Language.PlutusCore.StdLib.Data.Nat

-- | <tt>Nat</tt> as a PLC type.
--   
--   <pre>
--   fix \(nat :: *) -&gt; all r. r -&gt; (nat -&gt; r) -&gt; r
--   </pre>
getBuiltinNat :: Quote (RecursiveType ())

-- | '0' as a PLC term.
--   
--   <pre>
--   wrapNat [] /\(r :: *) -&gt; \(z : r) (f : nat -&gt; r) -&gt; z
--   </pre>
getBuiltinZero :: Quote (Term TyName Name ())

-- | <a>succ</a> as a PLC term.
--   
--   <pre>
--   \(n : nat) -&gt; wrapNat [] /\(r :: *) -&gt; \(z : r) (f : nat -&gt; r) -&gt; f n
--   </pre>
getBuiltinSucc :: Quote (Term TyName Name ())

-- | <tt>foldrNat</tt> as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(f : r -&gt; r) (z : r) -&gt;
--       fix {nat} {r} \(rec : nat -&gt; r) (n : nat) -&gt;
--           unwrap n {r} z \(n' : nat) -&gt; f (rec n')
--   </pre>
getBuiltinFoldrNat :: Quote (Term TyName Name ())

-- | <tt>foldNat</tt> as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(f : r -&gt; r) -&gt;
--       fix {r} {nat -&gt; r} \(rec : r -&gt; nat -&gt; r) (z : r) (n : nat) -&gt;
--           unwrap n {r} z (\(n' : nat) -&gt; rec (f z) n')
--   </pre>
getBuiltinFoldNat :: Quote (Term TyName Name ())

-- | Convert a <tt>nat</tt> to an <tt>integer</tt>.
--   
--   <pre>
--   /\(s :: size) -&gt; \(ss : size s) -&gt;
--       foldNat {integer s}
--           (addInteger {s} (resizeInteger {1} {s} ss 1!1))
--           (resizeInteger {1} {s} ss 1!0)
--   </pre>
getBuiltinNatToInteger :: Quote (Term TyName Name ())


-- | Functions related to <tt>integer</tt>.
module Language.PlutusCore.StdLib.Data.Integer

-- | <tt>succ :: Integer -&gt; Integer</tt> as a PLC term.
--   
--   <pre>
--   /\(s :: size) -&gt; \(i : integer s) -&gt;
--       addInteger {s} i (resizeInteger {1} {s} (sizeOfInteger {s} i) 1!1)
--   </pre>
getBuiltinSuccInteger :: Quote (Term TyName Name ())


-- | <tt>list</tt> and related functions.
module Language.PlutusCore.StdLib.Data.List

-- | <tt>List</tt> as a PLC type.
--   
--   <pre>
--   fix \(list :: * -&gt; *) (a :: *) -&gt; all (r :: *). r -&gt; (a -&gt; list a -&gt; r) -&gt; r
--   </pre>
getBuiltinList :: Quote (RecursiveType ())

-- | '[]' as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; wrapList [a] /\(r :: *) -&gt; \(z : r) (f : a -&gt; list a -&gt; r) -&gt; z)
--   </pre>
getBuiltinNil :: Quote (Term TyName Name ())

-- | '(:)' as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(x : a) (xs : list a) -&gt;
--       wrapList [a] /\(r :: *) -&gt; \(z : r) (f : a -&gt; list a -&gt; r) -&gt; f x xs
--   </pre>
getBuiltinCons :: Quote (Term TyName Name ())

-- | <tt>foldrList</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : a -&gt; r -&gt; r) (z : r) -&gt;
--       fix {list a} {r} \(rec : list a -&gt; r) (xs : list a) -&gt;
--           unwrap xs {r} z \(x : a) (xs' : list a) -&gt; f x (rec xs')
--   </pre>
getBuiltinFoldrList :: Quote (Term TyName Name ())

-- | 'foldl\'' as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : r -&gt; a -&gt; r) -&gt;
--       fix {r} {list a -&gt; r} \(rec : r -&gt; list a -&gt; r) (z : r) (xs : list a) -&gt;
--           unwrap xs {r} z \(x : a) (xs' : list a) -&gt; rec (f z x) xs'
--   </pre>
getBuiltinFoldList :: Quote (Term TyName Name ())

-- | <a>enumFromTo</a> as a PLC term
--   
--   <pre>
--   /\(s :: size) -&gt; (n m : integer s) -&gt;
--       fix {integer s} {list (integer s)}
--           (\(rec : integer s -&gt; list (integer s)) (n' : integer s) -&gt;
--               ifThenElse {list (integer s)}
--                   (greaterThanInteger {integer s} n' m)
--                   (nil {integer s})
--                   (cons {integer s} n' (rec (succInteger {s} n'))))
--           n
--   </pre>
getBuiltinEnumFromTo :: Quote (Term TyName Name ())

-- | <a>sum</a> as a PLC term.
--   
--   <pre>
--   /\(s :: *) -&gt; \(ss : size s) -&gt;
--       foldList {integer s} {integer s} (addInteger {s}) (resizeInteger {1} {s} ss 1!0)
--   </pre>
getBuiltinSum :: Quote (Term TyName Name ())

-- | <a>product</a> as a PLC term.
--   
--   <pre>
--   /\(s :: *) -&gt; \(ss : size s) -&gt;
--       foldList {integer s} {integer s} (multiplyInteger {s}) (resizeInteger {1} {s} ss 1!1)
--   </pre>
getBuiltinProduct :: Quote (Term TyName Name ())


-- | Functions that generate Plutus Core terms from Haskell values and vice
--   versa.
module Language.PlutusCore.StdLib.Meta

-- | Convert an <a>Integer</a> to a <tt>nat</tt>. TODO: convert PLC's
--   <tt>integer</tt> to <tt>nat</tt> instead.
getBuiltinIntegerToNat :: Integer -> Quote (Term TyName Name ())

-- | Convert a Haskell <a>Either</a> to a PLC <tt>sum</tt>.
getEitherToBuiltinSum :: Type TyName () -> Type TyName () -> Either (Term TyName Name ()) (Term TyName Name ()) -> Quote (Term TyName Name ())

-- | Convert a Haskell list of <a>Term</a>s to a PLC <tt>list</tt>.
getListToBuiltinList :: Type TyName () -> [Term TyName Name ()] -> Quote (Term TyName Name ())


-- | This module exports everything from the stdlib via a data type which
--   allows to test various procedures (pretty-printing, type checking,
--   etc) over the entire stdlib in a convenient way: each time a function
--   / data type is added to the stdlib, none of the tests is required to
--   be adapted, instead you just add the new definition to <a>stdLib</a>
--   defined below and all the tests see it automatically.
module Language.PlutusCore.StdLib.Everything

-- | The entire stdlib exported as a single value.
stdLib :: PlcFolderContents

module Language.PlutusCore.TH

-- | A quasiquoter for creating Plutus Core terms.
plcTerm :: QuasiQuoter

-- | A quasiquoter for creating Plutus Core types.
plcType :: QuasiQuoter

-- | A quasiquoter for creating Plutus Core programs.
plcProgram :: QuasiQuoter


-- | Reexports from modules from the <tt>Dynamic</tt> folder.
module Language.PlutusCore.Constant.Dynamic
newtype OnChain (names :: [Symbol]) f (tyname :: * -> *) (name :: * -> *) ann
OnChain :: f tyname name ann -> OnChain f ann
[unOnChain] :: OnChain f ann -> f tyname name ann

-- | The type of evaluators that run on-chain. This is very similar to
--   <a>Evaluator</a>, except an <a>OnChainEvaluator</a> is allowed to
--   return any <tt>r</tt>, not just a <tt>m EvaluationResult</tt> for some
--   <tt>m</tt>. This is because an evaluator running on-chain can perform
--   arbitrary effects and return an arbitrary result containing an
--   <tt>EvaluationResult</tt> somewhere deep inside <tt>r</tt>.
type OnChainEvaluator names f r = DynamicBuiltinNameMeanings -> OnChain names f TyName Name () -> r

-- | The type of functions that transform <a>OnChainEvaluator</a>s.
type OnChainTransformer f names r names' r' = OnChainEvaluator names f r -> OnChainEvaluator names' f r'

-- | The type of handlers of outermost dynamic built-in names.
type OnChainHandler name f r s = forall names. OnChainTransformer f names r (name : names) s
mangleOnChain :: OnChain names f tyname name ann -> OnChain names' f tyname name ann

-- | Interpret a <a>DynamicBuiltinNameMeaning</a> as an
--   <a>OnChainHandler</a> that doesn't change the resulting type of
--   evaluation.
handleDynamicByMeaning :: forall name f r. KnownSymbol name => DynamicBuiltinNameMeaning -> OnChainHandler name f r r
dynamicEmit :: Term tyname name ()
handleDynamicEmit :: OnChainHandler "emit" f r (forall a. (forall size. TypedBuiltin size a) -> IO ([a], r))
dynamicLog :: Term tyname name ()
handleDynamicLog :: OnChainHandler "log" f r (IO ([String], r))
evaluateHandlersBy :: Evaluator f m -> (Evaluator (OnChain '[] f) m -> OnChainEvaluator names f r) -> OnChain names f TyName Name () -> r
newtype PlcList a
PlcList :: [a] -> PlcList a
[unPlcList] :: PlcList a -> [a]
withEmit :: ((a -> IO ()) -> IO b) -> IO ([a], b)
newtype EmitHandler r
EmitHandler :: DynamicBuiltinNameMeanings -> Term TyName Name () -> IO r -> EmitHandler r
[unEmitHandler] :: EmitHandler r -> DynamicBuiltinNameMeanings -> Term TyName Name () -> IO r
feedEmitHandler :: Term TyName Name () -> EmitHandler r -> IO r
withEmitHandler :: Evaluator Term m -> (EmitHandler (m EvaluationResult) -> IO r2) -> IO r2
withEmitTerm :: (forall size. TypedBuiltin size a) -> (Term TyName Name () -> EmitHandler r1 -> IO r2) -> EmitHandler r1 -> IO ([a], r2)
withEmitEvaluateBy :: Evaluator Term m -> (forall size. TypedBuiltin size a) -> (Term TyName Name () -> Term TyName Name ()) -> IO ([a], m EvaluationResult)
dynamicCallAssign :: (forall size. TypedBuiltin size a) -> DynamicBuiltinName -> (a -> IO ()) -> DynamicBuiltinNameDefinition
dynamicCallTypeScheme :: (forall size. TypedBuiltin size a) -> (forall size. TypeScheme size (a -> ()) ())
dynamicCall :: DynamicBuiltinName -> Term tyname name ()
dynamicCharToStringName :: DynamicBuiltinName
dynamicCharToStringMeaning :: DynamicBuiltinNameMeaning
dynamicCharToStringDefinition :: DynamicBuiltinNameDefinition
dynamicCharToString :: Term tyname name ()
dynamicAppendName :: DynamicBuiltinName
dynamicAppendMeaning :: DynamicBuiltinNameMeaning
dynamicAppendDefinition :: DynamicBuiltinNameDefinition
dynamicAppend :: Term tyname name ()
dynamicTraceName :: DynamicBuiltinName


-- | Reexports from modules from the <tt>Constant</tt> folder.
module Language.PlutusCore.Constant

-- | Built-in types indexed by <tt>size</tt>.
data BuiltinSized
BuiltinSizedInt :: BuiltinSized
BuiltinSizedBS :: BuiltinSized
BuiltinSizedSize :: BuiltinSized

-- | Built-in types indexed by <tt>size</tt> along with their denotation.
data TypedBuiltinSized a
[TypedBuiltinSizedInt] :: TypedBuiltinSized Integer
[TypedBuiltinSizedBS] :: TypedBuiltinSized ByteString
[TypedBuiltinSizedSize] :: TypedBuiltinSized ()

-- | Type-level sizes.
data SizeEntry size

-- | A constant size.
SizeValue :: Size -> SizeEntry size

-- | A bound size variable.
SizeBound :: size -> SizeEntry size

-- | Built-in types.
data BuiltinType size
BuiltinSized :: (SizeEntry size) -> BuiltinSized -> BuiltinType size
BuiltinBool :: BuiltinType size

-- | Built-in types. A type is considired "built-in" if it can appear in
--   the type signature of a primitive operation. So <tt>boolean</tt> is
--   considered built-in even though it is defined in PLC and is not
--   primitive.
data TypedBuiltin size a
[TypedBuiltinSized] :: SizeEntry size -> TypedBuiltinSized a -> TypedBuiltin size a
[TypedBuiltinBool] :: TypedBuiltin size Bool
[TypedBuiltinDyn] :: KnownDynamicBuiltinType dyn => TypedBuiltin size dyn

-- | A <a>TypedBuiltin</a> packaged together with a value of the type that
--   the <a>TypedBuiltin</a> denotes.
data TypedBuiltinValue size a
TypedBuiltinValue :: (TypedBuiltin size a) -> a -> TypedBuiltinValue size a

-- | Type schemes of primitive operations. <tt>a</tt> is the Haskell
--   denotation of a PLC type represented as a <a>TypeScheme</a>.
--   <tt>r</tt> is the resulting type in <tt>a</tt>, e.g. the resulting
--   type in <tt>ByteString -&gt; Size -&gt; Integer</tt> is
--   <tt>Integer</tt>.
data TypeScheme size a r
[TypeSchemeBuiltin] :: TypedBuiltin size a -> TypeScheme size a a
[TypeSchemeArrow] :: TypeScheme size a q -> TypeScheme size b r -> TypeScheme size (a -> b) r
[TypeSchemeAllSize] :: (size -> TypeScheme size a r) -> TypeScheme size a r

-- | A <a>BuiltinName</a> with an associated <a>TypeScheme</a>.
data TypedBuiltinName a r
TypedBuiltinName :: BuiltinName -> (forall size. TypeScheme size a r) -> TypedBuiltinName a r

-- | The meaning of a dynamic built-in name consists of its <a>Type</a>
--   represented as a <a>TypeScheme</a> and its Haskell denotation.
data DynamicBuiltinNameMeaning
DynamicBuiltinNameMeaning :: (forall size. TypeScheme size a r) -> a -> DynamicBuiltinNameMeaning

-- | The definition of a dynamic built-in consists of its name and meaning.
data DynamicBuiltinNameDefinition
DynamicBuiltinNameDefinition :: DynamicBuiltinName -> DynamicBuiltinNameMeaning -> DynamicBuiltinNameDefinition

-- | Mapping from <a>DynamicBuiltinName</a>s to their
--   <a>DynamicBuiltinNameMeaning</a>s.
newtype DynamicBuiltinNameMeanings
DynamicBuiltinNameMeanings :: Map DynamicBuiltinName DynamicBuiltinNameMeaning -> DynamicBuiltinNameMeanings
[unDynamicBuiltinNameMeanings] :: DynamicBuiltinNameMeanings -> Map DynamicBuiltinName DynamicBuiltinNameMeaning
type Evaluator f m = DynamicBuiltinNameMeanings -> f TyName Name () -> m EvaluationResult
type Evaluate m = ReaderT (Evaluator Term m) m

-- | Haskell types known to exist on the PLC side.
class KnownDynamicBuiltinType dyn

-- | The type representing <tt>dyn</tt> used on the PLC side.
getTypeEncoding :: KnownDynamicBuiltinType dyn => proxy dyn -> Quote (Type TyName ())

-- | Convert a Haskell value to the corresponding PLC value. <a>Nothing</a>
--   represents a conversion failure.
makeDynamicBuiltin :: KnownDynamicBuiltinType dyn => dyn -> Quote (Maybe (Term TyName Name ()))

-- | Convert a PLC value to the corresponding Haskell value. <a>Nothing</a>
--   represents a conversion failure.
readDynamicBuiltin :: (KnownDynamicBuiltinType dyn, Monad m) => Evaluator Term m -> Term TyName Name () -> m (Maybe dyn)

-- | Convert a <a>TypedBuiltinSized</a> to its untyped counterpart.
eraseTypedBuiltinSized :: TypedBuiltinSized a -> BuiltinSized
runEvaluate :: Evaluator Term m -> Evaluate m a -> m a
withEvaluator :: (Evaluator Term m -> m a) -> Evaluate m a
readDynamicBuiltinM :: (Monad m, KnownDynamicBuiltinType dyn) => Term TyName Name () -> Evaluate m (Maybe dyn)

-- | Typed <a>AddInteger</a>.
typedAddInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>SubtractInteger</a>.
typedSubtractInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>MultiplyInteger</a>.
typedMultiplyInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>DivideInteger</a>.
typedDivideInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>QuotientInteger</a>
typedQuotientInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>ModInteger</a>
typedModInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>RemainderInteger</a>.
typedRemainderInteger :: TypedBuiltinName (Integer -> Integer -> Integer) Integer

-- | Typed <a>LessThanInteger</a>.
typedLessThanInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>LessThanEqInteger</a>.
typedLessThanEqInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>GreaterThanInteger</a>.
typedGreaterThanInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>GreaterThanEqInteger</a>.
typedGreaterThanEqInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>EqInteger</a>.
typedEqInteger :: TypedBuiltinName (Integer -> Integer -> Bool) Bool

-- | Typed <a>ResizeInteger</a>.
typedResizeInteger :: TypedBuiltinName (() -> Integer -> Integer) Integer

-- | Typed <a>IntToByteString</a>.
typedIntToByteString :: TypedBuiltinName (() -> Integer -> ByteString) ByteString

-- | Typed <a>Concatenate</a>.
typedConcatenate :: TypedBuiltinName (ByteString -> ByteString -> ByteString) ByteString

-- | Typed <a>TakeByteString</a>.
typedTakeByteString :: TypedBuiltinName (Integer -> ByteString -> ByteString) ByteString

-- | Typed <a>DropByteString</a>.
typedDropByteString :: TypedBuiltinName (Integer -> ByteString -> ByteString) ByteString

-- | Typed <a>SHA2</a>.
typedSHA2 :: TypedBuiltinName (ByteString -> ByteString) ByteString

-- | Typed <a>SHA3</a>.
typedSHA3 :: TypedBuiltinName (ByteString -> ByteString) ByteString

-- | Typed <a>VerifySignature</a>.
typedVerifySignature :: TypedBuiltinName (ByteString -> ByteString -> ByteString -> Bool) Bool

-- | Typed <a>ResizeByteString</a>.
typedResizeByteString :: TypedBuiltinName (() -> ByteString -> ByteString) ByteString

-- | Typed <a>EqByteString</a>.
typedEqByteString :: TypedBuiltinName (ByteString -> ByteString -> Bool) Bool

-- | Typed <a>TxHash</a>.
typedTxHash :: TypedBuiltinName ByteString ByteString

-- | Typed <a>BlockNum</a>.
typedBlockNum :: TypedBuiltinName (() -> Integer) Integer

-- | Typed <a>SizeOfInteger</a>.
typedSizeOfInteger :: TypedBuiltinName (Integer -> ()) ()

-- | Lift a <a>BuiltinName</a> to <a>Term</a>.
builtinNameAsTerm :: BuiltinName -> Term tyname name ()

-- | Lift a <a>DynamicBuiltinName</a> to <a>Term</a>.
dynamicBuiltinNameAsTerm :: DynamicBuiltinName -> Term tyname name ()

-- | Return the <tt>[-2^(8s - 1), 2^(8s - 1))</tt> bounds for integers of a
--   given <a>Size</a>.
toBoundsInt :: Size -> (Integer, Integer)

-- | Return the <tt>[-2^(8s - 1), 2^(8s - 1) - 1]</tt> bounds for integers
--   of a given <a>Size</a>.
toInclusiveBoundsInt :: Size -> (Integer, Integer)

-- | Check whether an <a>Integer</a> is in the <tt>[-2^(8s - 1), 2^(8s -
--   1))</tt> interval.
checkBoundsInt :: Size -> Integer -> Bool

-- | Check whether the length of a <tt>ByteString</tt> is less than or
--   equal to a given <a>Size</a>.
checkBoundsBS :: Size -> ByteString -> Bool

-- | Compute the size of an <a>Integer</a>. See also <a>toBoundsInt</a>.
sizeOfInteger :: Integer -> Size

-- | Compute the size of a <tt>ByteString</tt>. See also
--   <tt>toBoundsBS</tt>.
sizeOfByteString :: ByteString -> Size

-- | Make a <a>Constant</a> out of an <a>Integer</a>. The size is computed
--   using <a>sizeOfInteger</a>.
makeAutoSizedBuiltinInt :: Integer -> Constant ()

-- | Make a <a>Constant</a> out of a <tt>ByteString</tt>. The size is
--   computed using <tt>sizeOfBS</tt>.
makeAutoSizedBuiltinBS :: ByteString -> Constant ()

-- | Convert a Haskell <a>Integer</a> to the corresponding PLC
--   <tt>integer</tt>.
makeDynBuiltinInt :: Type tyname () -> Term tyname name () -> Integer -> Term tyname name ()

-- | Convert a Haskell <a>Integer</a> to the corresponding PLC
--   <tt>integer</tt>, taking the size singleton from an already existing
--   PLC <tt>integer</tt>.
makeDynBuiltinIntSizedAs :: Type tyname () -> Term tyname name () -> Integer -> Term tyname name ()

-- | Check whether an <a>Integer</a> is in bounds (see
--   <a>checkBoundsInt</a>) and return it as a <a>Constant</a>.
makeBuiltinInt :: Size -> Integer -> Maybe (Constant ())

-- | Check whether a <tt>ByteString</tt> is in bounds (see
--   <a>checkBoundsBS</a>) and return it as a <a>Constant</a>.
makeBuiltinBS :: Size -> ByteString -> Maybe (Constant ())
makeBuiltinStr :: String -> Constant ()

-- | Convert a Haskell value to the corresponding PLC constant indexed by
--   size checking all constraints (e.g. an <a>Integer</a> is in
--   appropriate bounds) along the way.
makeSizedConstant :: Size -> TypedBuiltinSized a -> a -> Maybe (Constant ())

-- | Convert a <a>Bool</a> to the corresponding PLC's <tt>boolean</tt>.
makeBuiltinBool :: Bool -> Quote (Term TyName Name ())

-- | Convert a Haskell value to the corresponding PLC value checking all
--   constraints (e.g. an <a>Integer</a> is in appropriate bounds) along
--   the way.
makeBuiltin :: TypedBuiltinValue Size a -> Quote (Maybe (Term TyName Name ()))

-- | Convert a Haskell value to a PLC value checking all constraints (e.g.
--   an <a>Integer</a> is in appropriate bounds) along the way and fail in
--   case constraints are not satisfied.
unsafeMakeBuiltin :: PrettyDynamic a => TypedBuiltinValue Size a -> Quote (Term TyName Name ())

-- | Convert a Haskell value to a PLC value of a dynamic built-in type.
unsafeMakeDynamicBuiltin :: (KnownDynamicBuiltinType dyn, PrettyDynamic dyn) => dyn -> Quote (Term TyName Name ())

-- | Convert a Haskell value to the corresponding PLC constant indexed by
--   size without checking constraints (e.g. an <a>Integer</a> is in
--   appropriate bounds). This function allows to fake a <a>Constant</a>
--   with a wrong size and thus it's highly unsafe and should be used with
--   great caution.
makeSizedConstantNOCHECK :: Size -> TypedBuiltinSized a -> a -> Constant ()

-- | Convert a Haskell value to the corresponding PLC value without
--   checking constraints (e.g. an <a>Integer</a> is in appropriate
--   bounds). This function allows to fake a <a>Term</a> with a wrong size
--   and thus it's highly unsafe and should be used with great caution.
makeBuiltinNOCHECK :: PrettyDynamic a => TypedBuiltinValue Size a -> Quote (Term TyName Name ())

-- | Extract the <a>Size</a> from a <a>SizeEntry</a>.
flattenSizeEntry :: SizeEntry Size -> Size

-- | Convert a <a>TypedBuiltinSized</a> to its untyped counterpart.
eraseTypedBuiltinSized :: TypedBuiltinSized a -> BuiltinSized

-- | Alter the <a>SizeEntry</a> of a <a>TypedBuiltin</a>.
mapSizeEntryTypedBuiltin :: (SizeEntry size -> SizeEntry size') -> TypedBuiltin size a -> TypedBuiltin size' a

-- | Alter the <tt>size</tt> of a <tt>TypedBuiltin size</tt>.
mapSizeTypedBuiltin :: (size -> size') -> TypedBuiltin size a -> TypedBuiltin size' a

-- | Map each <a>SizeBound</a> to <a>SizeValue</a>.
closeTypedBuiltin :: TypedBuiltin Size a -> TypedBuiltin b a

-- | Convert a <a>TypedBuiltinSized</a> to the corresponding
--   <a>TypeBuiltin</a> and wrap the result in <a>TyBuiltin</a> to get a
--   <a>Type</a>.
typedBuiltinSizedToType :: TypedBuiltinSized a -> Type TyName ()

-- | Apply a continuation to the typed version of a <a>BuiltinSized</a>.
withTypedBuiltinSized :: BuiltinSized -> (forall a. TypedBuiltinSized a -> c) -> c

-- | Apply a continuation to the typed version of a <a>Builtin</a>.
withTypedBuiltin :: BuiltinType size -> (forall a. TypedBuiltin size a -> c) -> c

-- | The resulting <a>TypedBuiltin</a> of a <a>TypeScheme</a>.
typeSchemeResult :: TypeScheme () a r -> TypedBuiltin () r

-- | Convert a <a>TypedBuiltin</a> to the corresponding <a>Type</a>.
typedBuiltinToType :: TypedBuiltin (Type TyName ()) a -> Quote (Type TyName ())

-- | Convert a <a>TypeScheme</a> to the corresponding <a>Type</a>.
--   Basically, a map from the PHOAS representation to the FOAS one.
typeSchemeToType :: TypeScheme (Type TyName ()) a r -> Quote (Type TyName ())

-- | Extract the <a>TypeScheme</a> from a <a>DynamicBuiltinNameMeaning</a>
--   and convert it to the corresponding <a>Type</a>.
dynamicBuiltinNameMeaningToType :: DynamicBuiltinNameMeaning -> Quote (Type TyName ())

-- | Insert a <a>DynamicBuiltinNameDefinition</a> into a
--   <a>DynamicBuiltinNameMeanings</a>.
insertDynamicBuiltinNameDefinition :: DynamicBuiltinNameDefinition -> DynamicBuiltinNameMeanings -> DynamicBuiltinNameMeanings

-- | Apply a continuation to the typed version of a <a>BuiltinName</a>.
withTypedBuiltinName :: BuiltinName -> (forall a r. TypedBuiltinName a r -> c) -> c

-- | Return the <a>Type</a> of a <a>TypedBuiltinName</a>.
typeOfTypedBuiltinName :: TypedBuiltinName a r -> Quote (Type TyName ())

-- | Return the <a>Type</a> of a <a>BuiltinName</a>.
typeOfBuiltinName :: BuiltinName -> Quote (Type TyName ())

-- | Same as the <a>Pretty</a> class, but is specifically for dynamic
--   built-in types as their pretty-printing can be rather weird (see the
--   <tt>PrettyDynamic BSL.ByteString</tt> instance for example).
class PrettyDynamic a
prettyDynamic :: PrettyDynamic a => a -> Doc ann
prettyDynamic :: (PrettyDynamic a, Pretty a) => a -> Doc ann

-- | The type of constant applications errors.
data ConstAppError

-- | A mismatch between expected and actual sizes.
SizeMismatchConstAppError :: Size -> (Constant ()) -> ConstAppError

-- | A mismatch between the type of an argument function expects and its
--   actual type.
IllTypedConstAppError :: BuiltinSized -> (Constant ()) -> ConstAppError

-- | A constant is applied to more arguments than needed in order to
--   reduce. Note that this error occurs even if an expression is
--   well-typed, because constant application is supposed to be computed as
--   soon as there are enough arguments.
ExcessArgumentsConstAppError :: [Value TyName Name ()] -> ConstAppError

-- | An argument of a sized type is not a constant.
SizedNonConstantConstAppError :: (Value TyName Name ()) -> ConstAppError

-- | Could not construct denotation for a built-in.
UnreadableBuiltinConstAppError :: (Value TyName Name ()) -> ConstAppError

-- | The type of constant applications results.
data ConstAppResult

-- | Successfully computed a value.
ConstAppSuccess :: (Value TyName Name ()) -> ConstAppResult

-- | Not enough gas.
ConstAppFailure :: ConstAppResult

-- | Not enough arguments.
ConstAppStuck :: ConstAppResult

-- | An internal error occurred during evaluation.
ConstAppError :: ConstAppError -> ConstAppResult

-- | Same as <a>makeBuiltin</a>, but returns a <a>ConstAppResult</a>.
makeConstAppResult :: TypedBuiltinValue Size a -> Quote ConstAppResult

-- | Apply a function with a known <a>TypeScheme</a> to a list of
--   <a>Constant</a>s (unwrapped from <a>Value</a>s). Checks that the
--   constants are of expected types and there are no size mismatches.
applyTypeSchemed :: Monad m => TypeScheme SizeVar a r -> a -> [Value TyName Name ()] -> QuoteT (Evaluate m) ConstAppResult

-- | Apply a <a>TypedBuiltinName</a> to a list of <a>Constant</a>s
--   (unwrapped from <a>Value</a>s) Checks that the constants are of
--   expected types and there are no size mismatches.
applyBuiltinName :: Monad m => BuiltinName -> [Value TyName Name ()] -> QuoteT (Evaluate m) ConstAppResult


-- | The exceptions that an abstract machine can throw.
module Language.PlutusCore.Evaluation.MachineException

-- | Errors which can occur during a run of an abstract machine.
data MachineError err

-- | An attempt to reduce a not immediately reducible type instantiation.
NonPrimitiveInstantiationMachineError :: MachineError err

-- | An attempt to unwrap a not wrapped term.
NonWrapUnwrappedMachineError :: MachineError err

-- | An attempt to reduce a not immediately reducible application.
NonPrimitiveApplicationMachineError :: MachineError err

-- | An attempt to evaluate an open term.
OpenTermEvaluatedMachineError :: MachineError err

-- | An attempt to compute a constant application resulted in
--   <a>ConstAppError</a>.
ConstAppMachineError :: ConstAppError -> MachineError err
OtherMachineError :: err -> MachineError err

-- | The type of exceptions an abstract machine can throw.
data MachineException err
MachineException :: MachineError err -> Term TyName Name () -> MachineException err

-- | An error.
[_machineExceptionError] :: MachineException err -> MachineError err

-- | A <a>Term</a> that caused the error.
[_machineExceptionCause] :: MachineException err -> Term TyName Name ()
instance GHC.Classes.Eq err => GHC.Classes.Eq (Language.PlutusCore.Evaluation.MachineException.MachineException err)
instance GHC.Classes.Eq err => GHC.Classes.Eq (Language.PlutusCore.Evaluation.MachineException.MachineError err)
instance Data.Text.Prettyprint.Doc.Internal.Pretty err => GHC.Show.Show (Language.PlutusCore.Evaluation.MachineException.MachineException err)
instance (Data.Text.Prettyprint.Doc.Internal.Pretty err, Data.Typeable.Internal.Typeable err) => GHC.Exception.Exception (Language.PlutusCore.Evaluation.MachineException.MachineException err)
instance (PlutusPrelude.PrettyBy config (Language.PlutusCore.Type.Constant ()), PlutusPrelude.PrettyBy config (Language.PlutusCore.Type.Value Language.PlutusCore.Name.TyName Language.PlutusCore.Name.Name ()), Data.Text.Prettyprint.Doc.Internal.Pretty err) => PlutusPrelude.PrettyBy config (Language.PlutusCore.Evaluation.MachineException.MachineError err)


-- | The CK machine.
module Language.PlutusCore.Evaluation.CkMachine

-- | The CK machine-specific <a>MachineException</a>.
type CkMachineException = MachineException NoDynamicBuiltinNamesMachineError

-- | The parameterized type of results various evaluation engines return.
data EvaluationResultF a
EvaluationSuccess :: a -> EvaluationResultF a
EvaluationFailure :: EvaluationResultF a

-- | The type of results various evaluation engines return.
type EvaluationResult = EvaluationResultF (Value TyName Name ())
applyEvaluateCkBuiltinName :: BuiltinName -> [Value TyName Name ()] -> ConstAppResult

-- | Evaluate a term using the CK machine. May throw a
--   <a>CkMachineException</a>. This differs from the spec version: we do
--   not have the following rule:
--   
--   <pre>
--   s , {_ A} ◁ F ↦ s ◁ W  -- Fully saturated constant, {F A} ~&gt; W.
--   </pre>
--   
--   The reason for that is that the operational semantics of constant
--   applications is unaffected by types as it supports full type erasure,
--   hence <tt>{F A}</tt> can never compute if <tt>F</tt> does not compute,
--   so we simply do not introduce a rule that can't possibly fire.
evaluateCk :: Term TyName Name () -> EvaluationResult

-- | Run a program using the CK machine. May throw a
--   <a>CkMachineException</a>. Calls <a>evaluateCk</a> under the hood, so
--   the same caveats apply.
runCk :: Program TyName Name () -> EvaluationResult
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.PlutusCore.Evaluation.CkMachine.NoDynamicBuiltinNamesMachineError


-- | Serialise instances for Plutus Core types. Make sure to read the Note
--   [Stable encoding of PLC] before touching anything in this file.
module Language.PlutusCore.CBOR
instance Codec.Serialise.Class.Serialise Language.PlutusCore.DeBruijn.Index
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Lexer.Type.TypeBuiltin
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Lexer.Type.BuiltinName
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Name.Unique
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Name.Name a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Name.TyName a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Lexer.Type.Version a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Kind a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Type tyname a)
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Lexer.Type.DynamicBuiltinName
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Builtin a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Constant a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Term tyname name a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.MkPlc.VarDecl tyname name a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.MkPlc.TyVarDecl tyname a)
instance (Codec.Serialise.Class.Serialise a, Codec.Serialise.Class.Serialise (tyname a), Codec.Serialise.Class.Serialise (name a)) => Codec.Serialise.Class.Serialise (Language.PlutusCore.Type.Program tyname name a)
instance Codec.Serialise.Class.Serialise Language.PlutusCore.Lexer.AlexPosn
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.DeBruijn.DeBruijn a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Language.PlutusCore.DeBruijn.TyDeBruijn a)

module Language.PlutusCore

-- | Parse a <tt>ByteString</tt> containing a Plutus Core program,
--   returning a <a>ParseError</a> if syntactically invalid.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; parse "(program 0.1.0 [(con addInteger) x y])"
--   Right (Program (AlexPn 1 1 2) (Version (AlexPn 9 1 10) 0 1 0) (Apply (AlexPn 15 1 16) (Apply (AlexPn 15 1 16) (Constant (AlexPn 17 1 18) (BuiltinName (AlexPn 21 1 22) AddInteger)) (Var (AlexPn 33 1 34) (Name {nameAttribute = AlexPn 33 1 34, nameString = "x", nameUnique = Unique {unUnique = 0}}))) (Var (AlexPn 35 1 36) (Name {nameAttribute = AlexPn 35 1 36, nameString = "y", nameUnique = Unique {unUnique = 1}}))))
--   </pre>
parse :: ByteString -> Either (ParseError AlexPosn) (Program TyName Name AlexPosn)
parseST :: ByteString -> StateT IdentifierState (Except (ParseError AlexPosn)) (Program TyName Name AlexPosn)
parseTermST :: ByteString -> StateT IdentifierState (Except (ParseError AlexPosn)) (Term TyName Name AlexPosn)
parseTypeST :: ByteString -> StateT IdentifierState (Except (ParseError AlexPosn)) (Type TyName AlexPosn)

-- | Parse and rewrite so that names are globally unique, not just unique
--   within their scope.
parseScoped :: (AsParseError e AlexPosn, AsValueRestrictionError e TyName AlexPosn, AsUniqueError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program TyName Name AlexPosn)

-- | Parse a PLC program. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseProgram :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program TyName Name AlexPosn)

-- | Parse a PLC term. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseTerm :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Term TyName Name AlexPosn)

-- | Parse a PLC type. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseType :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Type TyName AlexPosn)

-- | A <a>Term</a> is a value.
data Term tyname name a

-- | A named variable
Var :: a -> (name a) -> Term tyname name a
TyAbs :: a -> (tyname a) -> (Kind a) -> (Term tyname name a) -> Term tyname name a
LamAbs :: a -> (name a) -> (Type tyname a) -> (Term tyname name a) -> Term tyname name a
Apply :: a -> (Term tyname name a) -> (Term tyname name a) -> Term tyname name a

-- | A constant term
Constant :: a -> (Constant a) -> Term tyname name a
Builtin :: a -> (Builtin a) -> Term tyname name a
TyInst :: a -> (Term tyname name a) -> (Type tyname a) -> Term tyname name a
Unwrap :: a -> (Term tyname name a) -> Term tyname name a
IWrap :: a -> (Type tyname a) -> (Type tyname a) -> (Term tyname name a) -> Term tyname name a
Error :: a -> (Type tyname a) -> Term tyname name a

-- | A <a>Type</a> assigned to expressions.
data Type tyname a
TyVar :: a -> (tyname a) -> Type tyname a
TyFun :: a -> (Type tyname a) -> (Type tyname a) -> Type tyname a

-- | Fix-point type, for constructing self-recursive types
TyIFix :: a -> (Type tyname a) -> (Type tyname a) -> Type tyname a
TyForall :: a -> (tyname a) -> (Kind a) -> (Type tyname a) -> Type tyname a

-- | Builtin type
TyBuiltin :: a -> TypeBuiltin -> Type tyname a

-- | Type-level size
TyInt :: a -> Natural -> Type tyname a
TyLam :: a -> (tyname a) -> (Kind a) -> (Type tyname a) -> Type tyname a
TyApp :: a -> (Type tyname a) -> (Type tyname a) -> Type tyname a

-- | A constant value.
data Constant a
BuiltinInt :: a -> Natural -> Integer -> Constant a
BuiltinBS :: a -> Natural -> ByteString -> Constant a
BuiltinSize :: a -> Natural -> Constant a
BuiltinStr :: a -> String -> Constant a
data Builtin a
BuiltinName :: a -> BuiltinName -> Builtin a
DynBuiltinName :: a -> DynamicBuiltinName -> Builtin a

-- | Kinds. Each type has an associated kind.
data Kind a
Type :: a -> Kind a
KindArrow :: a -> (Kind a) -> (Kind a) -> Kind a
Size :: a -> Kind a

-- | An error encountered during parsing.
data ParseError a
LexErr :: String -> ParseError a
Unexpected :: (Token a) -> ParseError a
Overflow :: a -> Natural -> Integer -> ParseError a

-- | Version of Plutus Core to be used for the program.
data Version a
Version :: a -> Natural -> Natural -> Natural -> Version a

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a <a>Version</a>
--   of the core language.
data Program tyname name a
Program :: a -> (Version a) -> (Term tyname name a) -> Program tyname name a

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name a
Name :: a -> Text -> Unique -> Name a
[nameAttribute] :: Name a -> a

-- | The identifier name, for use in error messages.
[nameString] :: Name a -> Text

-- | A <a>Unique</a> assigned to the name during lexing, allowing for cheap
--   comparisons in the compiler.
[nameUnique] :: Name a -> Unique

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName a
TyName :: Name a -> TyName a
[unTyName] :: TyName a -> Name a

-- | A unique identifier
newtype Unique
Unique :: Int -> Unique
[unUnique] :: Unique -> Int
type Size = Natural
type Value = Term

-- | Builtin functions
data BuiltinName
AddInteger :: BuiltinName
SubtractInteger :: BuiltinName
MultiplyInteger :: BuiltinName
DivideInteger :: BuiltinName
QuotientInteger :: BuiltinName
RemainderInteger :: BuiltinName
ModInteger :: BuiltinName
LessThanInteger :: BuiltinName
LessThanEqInteger :: BuiltinName
GreaterThanInteger :: BuiltinName
GreaterThanEqInteger :: BuiltinName
EqInteger :: BuiltinName
ResizeInteger :: BuiltinName
IntToByteString :: BuiltinName
Concatenate :: BuiltinName
TakeByteString :: BuiltinName
DropByteString :: BuiltinName
ResizeByteString :: BuiltinName
SHA2 :: BuiltinName
SHA3 :: BuiltinName
VerifySignature :: BuiltinName
EqByteString :: BuiltinName
TxHash :: BuiltinName
BlockNum :: BuiltinName
SizeOfInteger :: BuiltinName

-- | The type of dynamic built-in functions. I.e. functions that exist on
--   certain chains and do not exist on others. Each
--   <a>DynamicBuiltinName</a> has an associated type and operational
--   semantics -- this allows to type check and evaluate dynamic built-in
--   names just like static ones.
newtype DynamicBuiltinName
DynamicBuiltinName :: Text -> DynamicBuiltinName

-- | The name of a dynamic built-in name.
[unDynamicBuiltinName] :: DynamicBuiltinName -> Text

-- | Either a <a>BuiltinName</a> (known statically) or a
--   <a>DynamicBuiltinName</a> (known dynamically).
data StagedBuiltinName
StaticStagedBuiltinName :: BuiltinName -> StagedBuiltinName
DynamicStagedBuiltinName :: DynamicBuiltinName -> StagedBuiltinName

-- | A builtin type
data TypeBuiltin
TyByteString :: TypeBuiltin
TyInteger :: TypeBuiltin
TySize :: TypeBuiltin
TyString :: TypeBuiltin
newtype Normalized a
Normalized :: a -> Normalized a
[getNormalized] :: Normalized a -> a
type NormalizedType tyname a = Normalized (Type tyname a)
getNormalizedType :: NormalizedType tyname a -> Type tyname a

-- | The default version of Plutus Core supported by this library.
defaultVersion :: a -> Version a

-- | The list of all <a>BuiltinName</a>s.
allBuiltinNames :: [BuiltinName]
termLoc :: Term tyname name a -> a
tyLoc :: Type tyname a -> a
data AlexPosn
AlexPn :: !Int -> !Int -> !Int -> AlexPosn

-- | A function (called "head") applied to a list of arguments (called
--   "spine").
data IterApp head arg
IterApp :: head -> [arg] -> IterApp head arg
[_iterAppHead] :: IterApp head arg -> head
[_iterAppSpine] :: IterApp head arg -> [arg]

-- | An iterated application of a <a>Term</a> to a list of <a>Term</a>s.
type TermIterApp tyname name a = IterApp (Term tyname name a) (Term tyname name a)

-- | An iterated application of a <a>BuiltinName</a> to a list of
--   <a>Value</a>s.
type PrimIterApp tyname name a = IterApp StagedBuiltinName (Value tyname name a)
format :: (AsParseError e AlexPosn, MonadError e m) => PrettyConfigPlc -> ByteString -> m Text
formatDoc :: (AsParseError e AlexPosn, MonadError e m) => PrettyConfigPlc -> ByteString -> m (Doc a)
newtype Gas
Gas :: Natural -> Gas
[unGas] :: Gas -> Natural
data ValueRestrictionError tyname a
ValueRestrictionViolation :: a -> (tyname a) -> ValueRestrictionError tyname a
class AsValueRestrictionError r_a1xpB tyname_a1x7M a_a1x7N | r_a1xpB -> tyname_a1x7M a_a1x7N
_ValueRestrictionError :: AsValueRestrictionError r_a1xpB tyname_a1x7M a_a1x7N => Prism' r_a1xpB (ValueRestrictionError tyname_a1x7M a_a1x7N)
_ValueRestrictionViolation :: AsValueRestrictionError r_a1xpB tyname_a1x7M a_a1x7N => Prism' r_a1xpB (a_a1x7N, tyname_a1x7M a_a1x7N)

-- | Rename <a>Unique</a>s so that they're globally unique. In case there
--   are any free variables, they must be left untouched. Must always
--   assign new names to bound variables, so that <tt>rename</tt> can be
--   used for alpha renaming as well.
rename :: (Rename a, MonadQuote m) => a -> m a
check :: Program tyname name a -> Maybe (NormalizationError tyname name a)

-- | Ensure that all terms and types are well-formed accoring to Fig. 2
checkProgram :: (AsNormalizationError e TyName Name a, MonadError e m) => Program TyName Name a -> m ()

-- | Ensure that all terms and types are well-formed accoring to Fig. 2
checkTerm :: (AsNormalizationError e TyName Name a, MonadError e m) => Term TyName Name a -> m ()
data NormalizationError tyname name a
checkFile :: FilePath -> IO (Maybe Text)
isTypeValue :: Type tyname a -> Bool

-- | Check whether a <a>Term</a> is a <a>Value</a>. The term is assumed to
--   be valid.
isTermValue :: Term tyname name a -> Bool

-- | Type-check a program, returning a normalized type.
typecheckProgram :: (AsTypeError e a, MonadError e m, MonadQuote m) => TypeConfig -> Program TyName Name a -> m (NormalizedType TyName ())

-- | Type-check a term, returning a normalized type.
typecheckTerm :: (AsTypeError e a, MonadError e m, MonadQuote m) => TypeConfig -> Term TyName Name a -> m (NormalizedType TyName ())

-- | Kind-check a PLC type.
kindCheck :: (AsTypeError e a, MonadError e m, MonadQuote m) => TypeConfig -> Type TyName a -> m (Kind ())

-- | Extract the <a>TypeScheme</a> from a <a>DynamicBuiltinNameMeaning</a>
--   and convert it to the corresponding <tt>Type TyName</tt> for each row
--   of a <a>DynamicBuiltinNameMeanings</a>.
dynamicBuiltinNameMeaningsToTypes :: DynamicBuiltinNameMeanings -> DynamicBuiltinNameTypes

-- | Given a file at <tt>fibonacci.plc</tt>, <tt>fileType
--   "fibonacci.plc"</tt> will display its type or an error message.
fileType :: FilePath -> IO Text
fileNormalizeType :: Bool -> FilePath -> IO Text

-- | Given a file, display its type or an error message, optionally dumping
--   annotations and debug information.
fileTypeCfg :: PrettyConfigPlc -> FilePath -> IO Text

-- | Print the type of a program contained in a <tt>ByteString</tt>
printType :: (AsParseError e AlexPosn, AsValueRestrictionError e TyName AlexPosn, AsUniqueError e AlexPosn, AsTypeError e AlexPosn, MonadError e m) => ByteString -> m Text

-- | Print the type of a program contained in a <tt>ByteString</tt>
printNormalizeType :: (AsParseError e AlexPosn, AsValueRestrictionError e TyName AlexPosn, AsUniqueError e AlexPosn, AsTypeError e AlexPosn, MonadError e m) => Bool -> ByteString -> m Text

-- | An internal error occurred during type checking.
data InternalTypeError a
OpenTypeOfBuiltin :: (Type TyName ()) -> (Builtin ()) -> InternalTypeError a
data TypeError a
KindMismatch :: a -> (Type TyName ()) -> (Kind ()) -> (Kind ()) -> TypeError a
TypeMismatch :: a -> (Term TyName Name ()) -> (Type TyName ()) -> (NormalizedType TyName ()) -> TypeError a
UnknownDynamicBuiltinName :: a -> UnknownDynamicBuiltinNameError -> TypeError a
InternalTypeErrorE :: a -> (InternalTypeError a) -> TypeError a
FreeTypeVariableE :: (TyName a) -> TypeError a
FreeVariableE :: (Name a) -> TypeError a
OutOfGas :: TypeError a
class AsTypeError r_a1ysS a_a1y6U | r_a1ysS -> a_a1y6U
_TypeError :: AsTypeError r_a1ysS a_a1y6U => Prism' r_a1ysS (TypeError a_a1y6U)
_KindMismatch :: AsTypeError r_a1ysS a_a1y6U => Prism' r_a1ysS (a_a1y6U, Type TyName (), Kind (), Kind ())
_TypeMismatch :: AsTypeError r_a1ysS a_a1y6U => Prism' r_a1ysS (a_a1y6U, Term TyName Name (), Type TyName (), NormalizedType TyName ())
_UnknownDynamicBuiltinName :: AsTypeError r_a1ysS a_a1y6U => Prism' r_a1ysS (a_a1y6U, UnknownDynamicBuiltinNameError)
_InternalTypeErrorE :: AsTypeError r_a1ysS a_a1y6U => Prism' r_a1ysS (a_a1y6U, InternalTypeError a_a1y6U)
_FreeTypeVariableE :: AsTypeError r_a1ysS a_a1y6U => Prism' r_a1ysS (TyName a_a1y6U)
_FreeVariableE :: AsTypeError r_a1ysS a_a1y6U => Prism' r_a1ysS (Name a_a1y6U)
_OutOfGas :: AsTypeError r_a1ysS a_a1y6U => Prism' r_a1ysS ()

-- | Configuration of the type checker.
data TypeConfig
TypeConfig :: Bool -> DynamicBuiltinNameTypes -> TyVarKinds -> VarTypes -> Maybe Gas -> TypeConfig

-- | Whether to normalize type annotations.
[_typeConfigNormalize] :: TypeConfig -> Bool
[_typeConfigDynBuiltinNameTypes] :: TypeConfig -> DynamicBuiltinNameTypes
[_typeConfigTyVarKinds] :: TypeConfig -> TyVarKinds
[_typeConfigVarTypes] :: TypeConfig -> VarTypes

-- | The upper limit on the length of type reductions. If set to
--   <a>Nothing</a>, type reductions will be unbounded.
[_typeConfigGas] :: TypeConfig -> Maybe Gas

-- | Mapping from <a>DynamicBuiltinName</a>s to their <a>Type</a>s.
newtype DynamicBuiltinNameTypes
DynamicBuiltinNameTypes :: Map DynamicBuiltinName (NormalizedType TyName ()) -> DynamicBuiltinNameTypes
[unDynamicBuiltinNameTypes] :: DynamicBuiltinNameTypes -> Map DynamicBuiltinName (NormalizedType TyName ())

-- | The type checking monad contains the <a>TypeConfig</a> and it lets us
--   throw <a>TypeError</a>s.
type TypeCheckM ann = ReaderT TypeConfig (ExceptT (TypeError ann) Quote)

-- | Parse a program and typecheck it.
parseTypecheck :: (AsParseError e AlexPosn, AsValueRestrictionError e TyName AlexPosn, AsUniqueError e AlexPosn, AsNormalizationError e TyName Name AlexPosn, AsTypeError e AlexPosn, MonadError e m, MonadQuote m) => TypeConfig -> ByteString -> m (NormalizedType TyName ())

-- | Run the type checker with a default context.
runTypeCheckM :: TypeConfig -> TypeCheckM a b -> ExceptT (TypeError a) Quote b

-- | Typecheck a program.
typecheckPipeline :: (AsNormalizationError e TyName Name a, AsTypeError e a, MonadError e m, MonadQuote m) => TypeConfig -> Program TyName Name a -> m (NormalizedType TyName ())

-- | The default amount of gas to run the typechecker with.
defaultTypecheckerGas :: Maybe Gas
defaultTypecheckerCfg :: TypeConfig
data Error a
ParseErrorE :: (ParseError a) -> Error a
ValueRestrictionErrorE :: (ValueRestrictionError TyName a) -> Error a
UniqueCoherencyErrorE :: (UniqueError a) -> Error a
TypeErrorE :: (TypeError a) -> Error a
NormalizationErrorE :: (NormalizationError TyName Name a) -> Error a
class AsError r_a1yNO a_a1ytH | r_a1yNO -> a_a1ytH
_Error :: AsError r_a1yNO a_a1ytH => Prism' r_a1yNO (Error a_a1ytH)
_ParseErrorE :: AsError r_a1yNO a_a1ytH => Prism' r_a1yNO (ParseError a_a1ytH)
_ValueRestrictionErrorE :: AsError r_a1yNO a_a1ytH => Prism' r_a1yNO (ValueRestrictionError TyName a_a1ytH)
_UniqueCoherencyErrorE :: AsError r_a1yNO a_a1ytH => Prism' r_a1yNO (UniqueError a_a1ytH)
_TypeErrorE :: AsError r_a1yNO a_a1ytH => Prism' r_a1yNO (TypeError a_a1ytH)
_NormalizationErrorE :: AsError r_a1yNO a_a1ytH => Prism' r_a1yNO (NormalizationError TyName Name a_a1ytH)

-- | This error is returned whenever scope resolution of a
--   <a>DynamicBuiltinName</a> fails.
newtype UnknownDynamicBuiltinNameError
UnknownDynamicBuiltinNameErrorE :: DynamicBuiltinName -> UnknownDynamicBuiltinNameError
data UniqueError a
MultiplyDefined :: Unique -> a -> a -> UniqueError a
IncoherentUsage :: Unique -> a -> a -> UniqueError a
FreeVariable :: Unique -> a -> UniqueError a
data TermF tyname name a x
VarF :: a -> (name a) -> TermF tyname name a x
TyAbsF :: a -> (tyname a) -> (Kind a) -> x -> TermF tyname name a x
LamAbsF :: a -> (name a) -> (Type tyname a) -> x -> TermF tyname name a x
ApplyF :: a -> x -> x -> TermF tyname name a x
ConstantF :: a -> (Constant a) -> TermF tyname name a x
BuiltinF :: a -> (Builtin a) -> TermF tyname name a x
TyInstF :: a -> x -> (Type tyname a) -> TermF tyname name a x
UnwrapF :: a -> x -> TermF tyname name a x
IWrapF :: a -> (Type tyname a) -> (Type tyname a) -> x -> TermF tyname name a x
ErrorF :: a -> (Type tyname a) -> TermF tyname name a x
data TypeF tyname a x
TyVarF :: a -> (tyname a) -> TypeF tyname a x
TyFunF :: a -> x -> x -> TypeF tyname a x
TyIFixF :: a -> x -> x -> TypeF tyname a x
TyForallF :: a -> (tyname a) -> (Kind a) -> x -> TypeF tyname a x
TyBuiltinF :: a -> TypeBuiltin -> TypeF tyname a x
TyIntF :: a -> Natural -> TypeF tyname a x
TyLamF :: a -> (tyname a) -> (Kind a) -> x -> TypeF tyname a x
TyAppF :: a -> x -> x -> TypeF tyname a x

-- | A non-transformer version of <a>QuoteT</a>.
type Quote = QuoteT Identity

-- | See <a>runQuoteT</a>.
runQuote :: Quote a -> a

-- | The "quotation" monad transformer. Within this monad you can do safe
--   construction of PLC terms using quasiquotation, fresh-name generation,
--   and parsing.
data QuoteT m a

-- | Run a quote from an empty identifier state. Note that the resulting
--   term cannot necessarily be safely combined with other terms - that
--   should happen inside <a>QuoteT</a>.
runQuoteT :: (Monad m) => QuoteT m a -> m a

-- | A monad that allows lifting of quoted expressions.
class Monad m => MonadQuote m
liftQuote :: MonadQuote m => Quote a -> m a

-- | Get a fresh <a>Unique</a>.
freshUnique :: MonadQuote m => m Unique

-- | Get a fresh <a>Name</a>, given the annotation and the <a>Text</a>
--   name.
freshName :: Monad m => a -> Text -> QuoteT m (Name a)

-- | Get a fresh <a>TyName</a>, given the annotation and the <a>Text</a>
--   name.
freshTyName :: Monad m => a -> Text -> QuoteT m (TyName a)

-- | A quasiquoter for creating Plutus Core types.
plcType :: QuasiQuoter

-- | A quasiquoter for creating Plutus Core terms.
plcTerm :: QuasiQuoter

-- | A quasiquoter for creating Plutus Core programs.
plcProgram :: QuasiQuoter

-- | The parameterized type of results various evaluation engines return.
data EvaluationResultF a
EvaluationSuccess :: a -> EvaluationResultF a
EvaluationFailure :: EvaluationResultF a

-- | The type of results various evaluation engines return.
type EvaluationResult = EvaluationResultF (Value TyName Name ())

-- | Take one PLC program and apply it to another.
applyProgram :: Program tyname name () -> Program tyname name () -> Program tyname name ()

module PlcTestUtils

-- | Class for ad-hoc overloading of things which can be turned into a PLC
--   program. Any errors from the process should be caught.
class GetProgram a
getProgram :: GetProgram a => a -> ExceptT SomeException IO (Program TyName Name ())
catchAll :: a -> ExceptT SomeException IO a
rethrow :: ExceptT SomeException IO a -> IO a
trivialProgram :: Term TyName Name () -> Program TyName Name ()
runPlc :: GetProgram a => [a] -> ExceptT SomeException IO EvaluationResult
goldenPlc :: GetProgram a => String -> a -> TestNested
goldenPlcCatch :: GetProgram a => String -> a -> TestNested
goldenEval :: GetProgram a => String -> [a] -> TestNested
goldenEvalCatch :: GetProgram a => String -> [a] -> TestNested
instance PlcTestUtils.GetProgram a => PlcTestUtils.GetProgram (Control.Monad.Trans.Except.ExceptT GHC.Exception.SomeException GHC.Types.IO a)
instance PlcTestUtils.GetProgram (Language.PlutusCore.Type.Program Language.PlutusCore.Name.TyName Language.PlutusCore.Name.Name ())


-- | Reexports from modules from the
--   <tt>Language.PlutusCore.Generators.Internal</tt> folder.
module Language.PlutusCore.Generators

-- | <pre>
--   hoist lift
--   </pre>
liftT :: (MFunctor t, MonadTrans s, Monad m) => t m a -> t (s m) a

-- | Supply an environment to an inner <a>ReaderT</a>.
hoistSupply :: (MFunctor t, Monad m) => r -> t (ReaderT r m) a -> t m a

-- | Same as <a>choice</a>, but with a default generator to be used when
--   the supplied list of generators is empty.
choiceDef :: Monad m => GenT m a -> [GenT m a] -> GenT m a

-- | Generate a value, but do not show it in case an error occurs.
forAllNoShow :: Monad m => Gen a -> PropertyT m a

-- | Generate a value, but do not show it in case an error occurs. A
--   supplied generator has access to the <a>Monad</a> the whole property
--   has access to.
forAllNoShowT :: Monad m => GenT m a -> PropertyT m a

-- | Generate a value using the <a>Pretty</a> class for getting its
--   <a>String</a> representation.
forAllPretty :: (Monad m, Pretty a) => Gen a -> PropertyT m a

-- | Generate a value using the <a>Pretty</a> class for getting its
--   <a>String</a> representation. A supplied generator has access to the
--   <a>Monad</a> the whole property has access to.
forAllPrettyT :: (Monad m, Pretty a) => GenT m a -> PropertyT m a

-- | Generate a value using the <a>PrettyPlc</a> constraint for getting its
--   <a>String</a> representation.
forAllPrettyPlc :: (Monad m, PrettyPlc a) => Gen a -> PropertyT m a

-- | Generate a value using the <a>PrettyPlc</a> constraint for getting its
--   <a>String</a> representation. A supplied generator has access to the
--   <a>Monad</a> the whole property has access to.
forAllPrettyPlcT :: (Monad m, PrettyPlc a) => GenT m a -> PropertyT m a

-- | Generate a value wrapped in <a>Maybe</a> using the <a>PrettyPlc</a>
--   constraint for getting its <a>String</a> representation.
forAllPrettyPlcMaybe :: (Monad m, PrettyPlc a) => Gen (Maybe a) -> PropertyT m (Maybe a)

-- | Generate a value wrapped in <a>Maybe</a> using the <a>PrettyPlc</a>
--   constraint for getting its <a>String</a> representation. A supplied
--   generator has access to the <a>Monad</a> the whole property has access
--   to.
forAllPrettyPlcMaybeT :: (Monad m, PrettyPlc a) => GenT m (Maybe a) -> PropertyT m (Maybe a)

-- | Run a generator until it succeeds with a <a>Just</a>.
runQuoteSampleSucceed :: GenT Quote (Maybe a) -> IO a

-- | Throw a PLC error.
errorPlc :: PrettyPlc err => err -> b

-- | The type of errors that can occur during type-eval checking.
data TypeEvalCheckError
TypeEvalCheckErrorIllFormed :: (Error ()) -> TypeEvalCheckError

-- | The former is an expected result of evaluation, the latter -- is an
--   actual one.
TypeEvalCheckErrorIllEvaled :: (Value TyName Name ()) -> (Value TyName Name ()) -> TypeEvalCheckError

-- | Type-eval checking of a term results in a value of this type.
data TypeEvalCheckResult
TypeEvalCheckResult :: NormalizedType TyName () -> EvaluationResult -> TypeEvalCheckResult

-- | The type of the term.
[_termCheckResultType] :: TypeEvalCheckResult -> NormalizedType TyName ()

-- | The result of evaluation of the term.
[_termCheckResultValue] :: TypeEvalCheckResult -> EvaluationResult

-- | The monad type-eval checking runs in.
type TypeEvalCheckM = ExceptT TypeEvalCheckError Quote

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one.
typeEvalCheckBy :: (Term TyName Name () -> EvaluationResult) -> TermOf (TypedBuiltinValue Size a) -> TypeEvalCheckM (TermOf TypeEvalCheckResult)

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one. Throw an error in case something goes wrong.
unsafeTypeEvalCheck :: forall a. TermOf (TypedBuiltinValue Size a) -> Quote (Maybe (TermOf (Value TyName Name ())))

-- | A PLC <a>Term</a> along with the correspoding Haskell value.
data TermOf a
TermOf :: Term TyName Name () -> a -> TermOf a

-- | The PLC term
[_termOfTerm] :: TermOf a -> Term TyName Name ()

-- | The Haskell value.
[_termOfValue] :: TermOf a -> a

-- | A function of this type generates values of built-in typed (see
--   <a>TypedBuiltin</a> for the list of such types) and returns it along
--   with the corresponding PLC value. Bounds induced (as per the spec) by
--   the <a>Size</a> values must be met, but can be narrowed.
type TypedBuiltinGenT m = forall a. TypedBuiltin Size a -> GenT m (TermOf a)

-- | <a>TypedBuiltinGenT</a> specified to <a>Identity</a>.
type TypedBuiltinGen = TypedBuiltinGenT Identity

-- | Generate a UTF-8 lazy <tt>ByteString</tt> containg lower-case letters.
genLowerBytes :: Monad m => Range Int -> GenT m ByteString

-- | Update a typed built-ins generator by overwriting the
--   <tt>integer</tt>s generator.
updateTypedBuiltinGenInt :: MonadQuote m => (Integer -> Integer -> GenT m Integer) -> TypedBuiltinGenT m -> TypedBuiltinGenT m

-- | Update a typed built-ins generator by overwriting the
--   <tt>bytestring</tt>s generator.
updateTypedBuiltinGenBS :: MonadQuote m => (Int -> GenT m ByteString) -> TypedBuiltinGenT m -> TypedBuiltinGenT m

-- | Update a typed built-ins generator by overwriting the <tt>size</tt>s
--   generator.
updateTypedBuiltinGenSize :: MonadQuote m => TypedBuiltinGenT m -> TypedBuiltinGenT m

-- | Update a typed built-ins generator by overwriting the
--   <tt>boolean</tt>s generator.
updateTypedBuiltinGenBool :: MonadQuote m => GenT m Bool -> TypedBuiltinGenT m -> TypedBuiltinGenT m

-- | A built-ins generator that always fails.
genTypedBuiltinFail :: Monad m => TypedBuiltinGenT m

-- | A default sized built-ins generator that produces values in bounds
--   seen in the spec.
genTypedBuiltinDef :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces values outside of bounds
--   seen in the spec for <tt>integer</tt>s and <tt>bytestring</tt>s.
genTypedBuiltinOutOfBounds :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces small values in bounds seen
--   in the spec.
genTypedBuiltinSmall :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <a>Integer</a>s in bounds
--   narrowed by a factor of 2, so that one can use '(+)' or '(-)' over
--   such integers without the risk of getting an overflow.
genTypedBuiltinSum :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <a>Integer</a>s in bounds
--   narrowed by <tt>isqrtt</tt>, so that one can use '(*)' over such
--   integers without the risk of getting an overflow.
genTypedBuiltinMultiply :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that doesn't produce <tt>0 ::
--   Integer</tt>, so that one case use <a>div</a> or <a>mod</a> over such
--   integers without the risk of dividing by zero.
genTypedBuiltinDivide :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <a>Integer</a>s in the
--   <tt>(high <a>div</a> 2, high]</tt> interval, so that one can use '(+)'
--   over such integers and reliably get an overflow.
genTypedBuiltinAddFailure :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <a>Integer</a>s in the
--   <tt>(isqrt high, high]</tt> interval, so that one can use '(*)' over
--   such integers and reliably get an overflow.
genTypedBuiltinMultiplyFailure :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <tt>ByteString</tt>s of such
--   lengths that one can use <a>&lt;&gt;</a> over them without the risk of
--   getting an overflow.
genTypedBuiltinConcatenate :: MonadQuote m => TypedBuiltinGenT m

-- | A sized built-ins generator that produces <tt>ByteString</tt>s of such
--   lengths that one can use <a>&lt;&gt;</a> over them and reliably gen an
--   overflow.
genTypedBuiltinConcatenateFailure :: MonadQuote m => TypedBuiltinGenT m

-- | The type used in generators defined in this module. It's parameterized
--   by a <a>BuiltinGensT</a> which makes it possible to supply different
--   generators of built-in types. For example, <tt>genTypedBuiltinDiv</tt>
--   never generates a zero, so this generator can be used in order to
--   avoid the divide-by-zero exception. Supplied generators are of
--   arbitrary complexity and can call the currently running generator
--   recursively, for example.
type PlcGenT m = GenT (ReaderT (BuiltinGensT m) m)

-- | One iterated application of a <tt>head</tt> to <tt>arg</tt>s
--   represented in three distinct ways.
data IterAppValue head arg r
IterAppValue :: Term TyName Name () -> IterApp head arg -> TypedBuiltinValue Size r -> IterAppValue head arg r

-- | As a PLC <a>Term</a>.
[_iterTerm] :: IterAppValue head arg r -> Term TyName Name ()

-- | As an <a>IterApp</a>.
[_iterApp] :: IterAppValue head arg r -> IterApp head arg

-- | As a Haskell value.
[_iterTbv] :: IterAppValue head arg r -> TypedBuiltinValue Size r

-- | Run a <a>PlcGenT</a> computation by supplying built-ins generators.
runPlcT :: Monad m => GenT m Size -> TypedBuiltinGenT m -> PlcGenT m a -> GenT m a

-- | Generate a size from bounds.
genSizeIn :: Monad m => Size -> Size -> GenT m Size

-- | Generate a size using the default range of <tt>[2..4]</tt>.
genSizeDef :: Monad m => GenT m Size

-- | Either return a size taken from a <a>TypedBuiltinSized</a> or generate
--   one using <a>genSizeDef</a>.
genSizeFrom :: Monad m => TypedBuiltin Size a -> GenT m Size

-- | Generate a <a>BuiltinSized</a>.
genBuiltinSized :: Monad m => GenT m BuiltinSized

-- | Generate a <a>Builtin</a>.
genBuiltin :: Monad m => GenT m Size -> GenT m (BuiltinType size)

-- | Generate a <a>Builtin</a> and supply its typed version to a
--   continuation.
withTypedBuiltinGen :: Monad m => GenT m Size -> (forall a. TypedBuiltin size a -> GenT m c) -> GenT m c

-- | Generate a <a>Term</a> along with the value it computes to, having a
--   generator of terms of built-in types.
withCheckedTermGen :: TypedBuiltinGenT Quote -> (forall a. TypedBuiltin Size a -> Maybe (TermOf (Value TyName Name ())) -> GenT Quote c) -> GenT Quote c

-- | Generate an <a>IterAppValue</a> from a <a>Denotation</a>. If the
--   <a>Denotation</a> has a functional type, then all arguments are
--   generated and supplied to the denotation, the resulting value is
--   forced and if there are any exceptions, then all generated arguments
--   are discarded and another attempt is performed (this process does not
--   loop). Since <a>IterAppValue</a> consists of three components, we 1.
--   grow the <a>Term</a> component by applying it to arguments using
--   <a>Apply</a> 2. grow the <a>IterApp</a> component by appending
--   arguments to its spine 3. feed arguments to the Haskell function
genIterAppValue :: forall head r m. Monad m => Denotation head Size r -> PlcGenT m (IterAppValue head (Term TyName Name ()) r)

-- | Generate a PLC <a>Term</a> of the specified type and the corresponding
--   Haskell value. Generates first-order functions and constants including
--   constant applications. Arguments to functions and <a>BuiltinName</a>s
--   are generated recursively.
genTerm :: TypedBuiltinGenT Quote -> DenotationContext -> Int -> TypedBuiltinGenT Quote

-- | Generates a <a>Term</a> with rather small values to make out-of-bounds
--   failures less likely. There are still like a half of terms that fail
--   with out-of-bounds errors being evaluated.
genTermLoose :: TypedBuiltinGenT Quote

-- | Generate a <a>TypedBuiltin</a> and a <a>TermOf</a> of the
--   corresponding type, attach the <a>TypedBuiltin</a> to the value part
--   of the <a>TermOf</a> and pass that to a continuation.
withAnyTermLoose :: (forall a. TermOf (TypedBuiltinValue Size a) -> GenT Quote c) -> GenT Quote c

-- | Haskell denotation of a PLC object. An object can be a
--   <a>BuiltinName</a> or a variable for example.
data Denotation object size r
Denotation :: object -> object -> Term TyName Name () -> a -> TypeScheme size a r -> Denotation object size r

-- | A PLC object.
[_denotationObject] :: Denotation object size r -> object

-- | How to embed the object into a term.
[_denotationToTerm] :: Denotation object size r -> object -> Term TyName Name ()

-- | The denotation of the object. E.g. the denotation of <a>AddInteger</a>
--   is '(+)'.
[_denotationItself] :: Denotation object size r -> a

-- | The <a>TypeScheme</a> of the object. See <tt>sizeIntIntInt</tt> for
--   example.
[_denotationScheme] :: Denotation object size r -> TypeScheme size a r

-- | A member of a <a>DenotationContext</a>. <tt>object</tt> is
--   existentially quantified, so the only thing that can be done with it,
--   is turning it into a <a>Term</a> using <a>_denotationToTerm</a>.
data DenotationContextMember r
DenotationContextMember :: (Denotation object Size r) -> DenotationContextMember r

-- | A context of <a>DenotationContextMember</a>s. Each row is a mapping
--   from a type to a list of things that can return that type. For example
--   it can contain a mapping from <tt>integer</tt> to 1. a bound variable
--   of type <tt>integer</tt> 2. a bound variable of functional type with
--   the result being <tt>integer</tt> 3. the <a>AddInteger</a>
--   <a>BuiltinName</a> or any other <a>BuiltinName</a> which returns an
--   <tt>integer</tt>.
newtype DenotationContext
DenotationContext :: DMap (TypedBuiltin ()) (Compose [] DenotationContextMember) -> DenotationContext
[unDenotationContext] :: DenotationContext -> DMap (TypedBuiltin ()) (Compose [] DenotationContextMember)

-- | Get the <a>Denotation</a> of a variable.
denoteVariable :: Name () -> TypedBuiltin size r -> r -> Denotation (Name ()) size r

-- | Get the <a>Denotation</a> of a <a>TypedBuiltinName</a>.
denoteTypedBuiltinName :: TypedBuiltinName a r -> a -> Denotation BuiltinName size r

-- | Insert a variable into a <a>DenotationContext</a>.
insertVariable :: Name () -> TypedBuiltin Size a -> a -> DenotationContext -> DenotationContext

-- | Insert a <a>TypedBuiltinName</a> into a <a>DenotationContext</a>.
insertTypedBuiltinName :: TypedBuiltinName a r -> a -> DenotationContext -> DenotationContext

-- | A <a>DenotationContext</a> that consists of <a>TypedBuiltinName</a>s.
typedBuiltinNames :: DenotationContext


-- | Sample generators used for tests.
module Language.PlutusCore.Generators.Interesting

-- | The type of terms-and-their-values generators.
type TermGen size a = GenT Quote (TermOf (TypedBuiltinValue size a))

-- | Generates application of a built-in that returns a <tt>boolean</tt>,
--   immediately saturated afterwards.
--   
--   <pre>
--   lessThanInteger {integer s1} $i1 $i2 {integer s2} $j1 $j2 == if i1 &lt; i2 then j1 else j2
--   </pre>
genOverapplication :: TermGen size Integer

-- | <tt>i -&gt; product [1 :: Integer .. i]</tt> as a PLC term.
--   
--   <pre>
--   /\(s :: size) -&gt; \(i : integer s) -&gt;
--   </pre>
--   
--   let ss = sizeOfInteger {s} i in product {s} ss (enumFromTo {s}
--   (resizeInteger {1} {s} ss 1!1) i)
getBuiltinFactorial :: Quote (Term TyName Name ())

-- | Apply some factorial function to its <a>Size</a> and <a>Integer</a>
--   arguments. This function exist, because we have another implementation
--   via dynamic built-ins and want to compare it to the direct
--   implementation from the above.
applyFactorial :: Term TyName Name () -> Size -> Integer -> Term TyName Name ()

-- | Generate a term that computes the factorial of an <tt>integer</tt> and
--   return it along with the factorial of the corresponding <a>Integer</a>
--   computed on the Haskell side.
genFactorial :: TermGen size Integer

-- | Generate a term that computes the ith Fibonacci number and return it
--   along with the corresponding <a>Integer</a> computed on the Haskell
--   side.
genNaiveFib :: TermGen size Integer

-- | Generate an <a>Integer</a>, turn it into a Scott-encoded PLC
--   <tt>Nat</tt> (see <a>getBuiltinNat</a>), turn that <tt>Nat</tt> into
--   the corresponding PLC <tt>integer</tt> using a fold (see
--   <a>getBuiltinFoldNat</a>) defined in terms of generic fix (see
--   <a>getBuiltinFix</a>) and return the result along with the original
--   <a>Integer</a>
genNatRoundtrip :: GenT Quote (TermOf (TypedBuiltinValue size Integer))

-- | <tt>sumNat</tt> as a PLC term.
getBuiltinNatSum :: Size -> Quote (Term TyName Name ())

-- | Generate a list of <a>Integer</a>s, turn it into a Scott-encoded PLC
--   <tt>List</tt> (see <a>getBuiltinList</a>), sum elements of the list
--   (see <a>getBuiltinSum</a>) and return it along with the sum of the
--   original list.
genListSum :: TermGen size Integer

-- | Generate a <tt>boolean</tt> and two <tt>integer</tt>s and check
--   whether <tt>if b then i1 else i2</tt> means the same thing in Haskell
--   and PLC. Terms are generated using <a>genTermLoose</a>.
genIfIntegers :: TermGen size Integer

-- | Apply a function to all interesting generators and collect the
--   results.
fromInterestingTermGens :: (forall a. String -> TermGen size a -> c) -> [c]


-- | This module defines functions useful for testing.
module Language.PlutusCore.Generators.Test

-- | The type of errors that can occur during type-eval checking.
data TypeEvalCheckError
TypeEvalCheckErrorIllFormed :: (Error ()) -> TypeEvalCheckError

-- | The former is an expected result of evaluation, the latter -- is an
--   actual one.
TypeEvalCheckErrorIllEvaled :: (Value TyName Name ()) -> (Value TyName Name ()) -> TypeEvalCheckError

-- | Type-eval checking of a term results in a value of this type.
data TypeEvalCheckResult
TypeEvalCheckResult :: NormalizedType TyName () -> EvaluationResult -> TypeEvalCheckResult

-- | The type of the term.
[_termCheckResultType] :: TypeEvalCheckResult -> NormalizedType TyName ()

-- | The result of evaluation of the term.
[_termCheckResultValue] :: TypeEvalCheckResult -> EvaluationResult

-- | The monad type-eval checking runs in.
type TypeEvalCheckM = ExceptT TypeEvalCheckError Quote

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one.
typeEvalCheckBy :: (Term TyName Name () -> EvaluationResult) -> TermOf (TypedBuiltinValue Size a) -> TypeEvalCheckM (TermOf TypeEvalCheckResult)

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one. Throw an error in case something goes wrong.
unsafeTypeEvalCheck :: forall a. TermOf (TypedBuiltinValue Size a) -> Quote (Maybe (TermOf (Value TyName Name ())))

-- | Generate a term using a given generator and check that it's well-typed
--   and evaluates correctly.
sampleTermValue :: TermGen Size a -> IO (TermOf (Value TyName Name ()))

-- | Generate a term using a given generator, check that it's well-typed
--   and evaluates correctly and pretty-print it to stdout using the
--   default pretty-printing mode.
printSampleTermValue :: TermGen Size a -> IO ()

-- | Generate a pair of files: <tt><a>folder</a>.<a>name</a>.plc</tt> and
--   <tt><a>folder</a>.<a>name</a>.plc.golden</tt>. The first file contains
--   a term generated by a term generator (wrapped in <a>Program</a>), the
--   second file contains the result of evaluation of the term.
sampleProgramValueGolden :: String -> String -> TermGen Size a -> IO ()

-- | A property-based testing procedure for evaluators. Checks whether a
--   term generated along with the value it's supposed to compute to indeed
--   computes to that value according to the provided evaluate.
propEvaluate :: (Term TyName Name () -> EvaluationResult) -> GenT Quote (TermOf (TypedBuiltinValue Size a)) -> Property
