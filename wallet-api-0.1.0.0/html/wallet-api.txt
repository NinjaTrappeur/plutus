-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Wallet API
--   
--   Wallet API and emulator
@package wallet-api
@version 0.1.0.0


-- | A type for intervals and associated functions.
module Ledger.Interval

-- | Slot number
newtype Slot
Slot :: Int -> Slot
[getSlot] :: Slot -> Int

-- | An interval of <tt>a</tt>s. The interval is closed below and open
--   above, meaning that <tt>Interval (Just (10 :: Int)) (Just 11)</tt>
--   contains a single value <tt>11</tt>. The interval is unbounded on
--   either side: <tt>Interval Nothing (Just 12)</tt> contains all numbers
--   smaller than <tt>12</tt>.
data Interval a
Interval :: Maybe a -> Maybe a -> Interval a
[ivFrom] :: Interval a -> Maybe a
[ivTo] :: Interval a -> Maybe a
type SlotRange = Interval Slot

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than <tt>b</tt>. Therefore it includes
--   <tt>a</tt> but not it does not include <tt>b</tt>.
interval :: Q (TExp (a -> a -> Interval a))

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>.
from :: Q (TExp (a -> Interval a))

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than <tt>a</tt>.
to :: Q (TExp (a -> Interval a))

-- | A <a>SlotRange</a> that covers only a single slot.
singleton :: Q (TExp (Slot -> SlotRange))

-- | Check if a <a>SlotRange</a> is empty
empty :: Q (TExp (SlotRange -> Bool))

-- | A <a>SlotRange</a> that covers every slot.
always :: Q (TExp SlotRange)

-- | Check if <a>Slot</a> is contained in a <a>SlotRange</a>.
member :: Q (TExp (Slot -> SlotRange -> Bool))

-- | Number of <a>Slot</a>s covered by the interval. <tt>width (from x) ==
--   Nothing</tt>
width :: Q (TExp (SlotRange -> Maybe Int))

-- | <tt>a <a>contains</a> b</tt> is true if the <a>SlotRange</a>
--   <tt>b</tt> is entirely contained in <tt>a</tt>. That is, <tt>a
--   <a>contains</a> b</tt> if for every slot <tt>s</tt>, if <tt>member s
--   b</tt> then <tt>member s a</tt>.
contains :: Q (TExp (SlotRange -> SlotRange -> Bool))

-- | Check if a <a>Slot</a> is earlier than the beginning of a
--   <a>SlotRange</a>
before :: Q (TExp (Slot -> SlotRange -> Bool))

-- | Check if a <a>Slot</a> is later than the end of a <a>SlotRange</a>
after :: Q (TExp (Slot -> SlotRange -> Bool))
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Interval.Interval
instance (Language.PlutusTx.Lift.Class.Typeable a, Language.PlutusTx.Lift.Class.Lift (GHC.Base.Maybe a)) => Language.PlutusTx.Lift.Class.Lift (Ledger.Interval.Interval a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Ledger.Interval.Interval a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Ledger.Interval.Interval a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Ledger.Interval.Interval a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Ledger.Interval.Interval a)
instance GHC.Generics.Generic (Ledger.Interval.Interval a)
instance GHC.Show.Show a => GHC.Show.Show (Ledger.Interval.Interval a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Ledger.Interval.Interval a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Ledger.Interval.Interval a)
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Interval.Slot
instance Language.PlutusTx.Lift.Class.Lift Ledger.Interval.Slot
instance Codec.Serialise.Class.Serialise Ledger.Interval.Slot
instance GHC.Real.Integral Ledger.Interval.Slot
instance GHC.Real.Real Ledger.Interval.Slot
instance GHC.Num.Num Ledger.Interval.Slot
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Interval.Slot
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Interval.Slot
instance Data.Swagger.Internal.Schema.ToSchema Ledger.Interval.Slot
instance GHC.Generics.Generic Ledger.Interval.Slot
instance GHC.Enum.Enum Ledger.Interval.Slot
instance GHC.Show.Show Ledger.Interval.Slot
instance GHC.Classes.Ord Ledger.Interval.Slot
instance GHC.Classes.Eq Ledger.Interval.Slot

module Ledger.Types

-- | Cryptocurrency value
newtype Value
Value :: Int -> Value
[getValue] :: Value -> Int

-- | Slot number
newtype Slot
Slot :: Int -> Slot
[getSlot] :: Slot -> Int
type SlotRange = Interval Slot

-- | The number of the last slot of a blockchain. Assumes that empty slots
--   are represented as empty blocks (as opposed to no blocks). This is
--   true in the emulator but not necessarily on the real chain,
lastSlot :: Blockchain -> Slot

-- | Transaction ID (double SHA256 hash of the transaction)
newtype TxIdOf h
TxIdOf :: h -> TxIdOf h
[getTxId] :: TxIdOf h -> h
type TxId = TxIdOf (Digest SHA256)

-- | Public key
newtype PubKey
PubKey :: Int -> PubKey
[getPubKey] :: PubKey -> Int
newtype Signature
Signature :: Int -> Signature
[getSignature] :: Signature -> Int

-- | True if the signature matches the public key
signedBy :: Signature -> PubKey -> Bool

-- | A payment address is a double SHA256 of a UTxO output's validator
--   script (and presumably its data script). This corresponds to a
--   Bitcoing pay-to-witness-script-hash
newtype AddressOf h
AddressOf :: h -> AddressOf h
[getAddress] :: AddressOf h -> h
type Address = AddressOf (Digest SHA256)

-- | The address of a transaction output locked by public key
pubKeyAddress :: PubKey -> AddressOf (Digest SHA256)

-- | The address of a transaction output locked by a validator script
scriptAddress :: ValidatorScript -> AddressOf (Digest SHA256)

-- | Script
data Script
fromCompiledCode :: CompiledCode a -> Script

-- | Compile a quoted Haskell expression to a <a>Script</a>
compileScript :: Q (TExp a) -> Q (TExp Script)
lifted :: Lift a => a -> Script
applyScript :: Script -> Script -> Script
evaluateScript :: Script -> ([String], Bool)

-- | A validator is a PLC script.
newtype ValidatorScript
ValidatorScript :: Script -> ValidatorScript
[getValidator] :: ValidatorScript -> Script

-- | Redeemer (supplied by consumer of the transaction output)
newtype RedeemerScript
RedeemerScript :: Script -> RedeemerScript
[getRedeemer] :: RedeemerScript -> Script

-- | Data script (supplied by producer of the transaction output)
newtype DataScript
DataScript :: Script -> DataScript
[getDataScript] :: DataScript -> Script

-- | Transaction including witnesses for its inputs
data Tx
Tx :: Set TxIn -> [TxOut] -> !Value -> !Value -> !SlotRange -> Tx
[txInputs] :: Tx -> Set TxIn
[txOutputs] :: Tx -> [TxOut]
[txForge] :: Tx -> !Value
[txFee] :: Tx -> !Value

-- | The <a>SlotRange</a> during which this transaction may be validated
[txValidRange] :: Tx -> !SlotRange

-- | Transaction without witnesses for its inputs
data TxStripped
TxStripped :: Set TxOutRef -> [TxOut] -> !Value -> !Value -> TxStripped
[txStrippedInputs] :: TxStripped -> Set TxOutRef
[txStrippedOutputs] :: TxStripped -> [TxOut]
[txStrippedForge] :: TxStripped -> !Value
[txStrippedFee] :: TxStripped -> !Value
strip :: Tx -> TxStripped

-- | Hash a stripped transaction once
preHash :: TxStripped -> Digest SHA256

-- | Double hash of a transaction, excluding its witnesses
hashTx :: Tx -> TxId

-- | Determine the data script that an input refers to
dataTxo :: Blockchain -> TxOutRef -> Maybe DataScript

-- | Transaction input
data TxInOf h
TxInOf :: !(TxOutRefOf h) -> !TxInType -> TxInOf h
[txInRef] :: TxInOf h -> !(TxOutRefOf h)
[txInType] :: TxInOf h -> !TxInType

-- | Type of transaction input.
data TxInType
ConsumeScriptAddress :: !ValidatorScript -> !RedeemerScript -> TxInType
ConsumePublicKeyAddress :: !Signature -> TxInType
type TxIn = TxInOf (Digest SHA256)
data TxOutOf h
TxOutOf :: !(AddressOf h) -> !Value -> !TxOutType -> TxOutOf h
[txOutAddress] :: TxOutOf h -> !(AddressOf h)
[txOutValue] :: TxOutOf h -> !Value
[txOutType] :: TxOutOf h -> !TxOutType

-- | Type of transaction output.
data TxOutType

-- | A pay-to-script output with the data script
PayToScript :: !DataScript -> TxOutType

-- | A pay-to-pubkey output
PayToPubKey :: !PubKey -> TxOutType
type TxOut = TxOutOf (Digest SHA256)

-- | Reference to a transaction output
data TxOutRefOf h
TxOutRefOf :: TxIdOf h -> Int -> TxOutRefOf h
[txOutRefId] :: TxOutRefOf h -> TxIdOf h

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRefOf h -> Int
type TxOutRef = TxOutRefOf (Digest SHA256)
pubKeyTxIn :: TxOutRefOf h -> Signature -> TxInOf h
scriptTxIn :: TxOutRefOf h -> ValidatorScript -> RedeemerScript -> TxInOf h

-- | Create a transaction output locked by a public key
pubKeyTxOut :: Value -> PubKey -> TxOut

-- | Create a transaction output locked by a validator script
scriptTxOut :: Value -> ValidatorScript -> DataScript -> TxOut

-- | Returns true if the output is a pay-to-pubkey output
isPubKeyOut :: TxOutOf h -> Bool

-- | Returns true if the output is a pay-to-script output
isPayToScriptOut :: TxOutOf h -> Bool

-- | A list of a transaction's outputs paired with their [[TxOutRef]]s
txOutRefs :: Tx -> [(TxOut, TxOutRef)]
type Block = [Tx]
type Blockchain = [Block]

-- | Information about the state of the blockchain and about the
--   transaction that is currently being validated, represented as a value
--   in PLC.
--   
--   In the future we will generate this at transaction validation time,
--   but for now we have to construct it at compilation time (in the test
--   suite) and pass it to the validator.
newtype ValidationData
ValidationData :: Script -> ValidationData

-- | Lookup a transaction by its hash
transaction :: Blockchain -> TxOutRef -> Maybe Tx

-- | Determine the unspent output that an input refers to
out :: Blockchain -> TxOutRef -> Maybe TxOut

-- | Determine the unspent value that an input refers to
value :: Blockchain -> TxOutRef -> Maybe Value

-- | The unspent outputs of a transaction
unspentOutputsTx :: Tx -> Map TxOutRef TxOut

-- | The outputs consumed by a transaction
spentOutputs :: Tx -> Set TxOutRef

-- | Unspent outputs of a ledger.
unspentOutputs :: Blockchain -> Map TxOutRef TxOut

-- | Update a map of unspent transaction outputs and sigantures with the
--   inputs and outputs of a transaction.
updateUtxo :: Tx -> Map TxOutRef TxOut -> Map TxOutRef TxOut

-- | The public key that a [[TxOut]] refers to
txOutPubKey :: TxOutOf h -> Maybe PubKey

-- | Determine the public key that locks the txo
pubKeyTxo :: Blockchain -> TxOutRef -> Maybe PubKey

-- | Check that all values in a transaction are no.
validValuesTx :: Tx -> Bool

-- | () as a redeemer
unitRedeemer :: RedeemerScript

-- | () as a data script
unitData :: DataScript

-- | Evaluate a validator script with the given inputs
runScript :: ValidationData -> ValidatorScript -> RedeemerScript -> DataScript -> ([String], Bool)

-- | The inputs of a transaction
inputs :: Lens' Tx (Set TxIn)
outputs :: Lens' Tx [TxOut]

-- | The address of a transaction output
outAddress :: Lens (TxOutOf h) (TxOutOf g) (AddressOf h) (AddressOf g)

-- | The value of a transaction output | TODO: Compute address again
outValue :: Lens' (TxOutOf h) Value

-- | The type of a transaction output | TODO: Compute address again
outType :: Lens' (TxOutOf h) TxOutType

-- | The <a>TxOutRefOf</a> spent by a transaction input
inRef :: Lens (TxInOf h) (TxInOf g) (TxOutRefOf h) (TxOutRefOf g)

-- | The type of a transaction input
inType :: Lens' (TxInOf h) TxInType

-- | Validator and redeemer scripts of a transaction input that spends a
--   "pay to script" output
inScripts :: TxInOf h -> Maybe (ValidatorScript, RedeemerScript)

-- | Signature of a transaction input that spends a "pay to public key"
--   output
inSignature :: TxInOf h -> Maybe Signature
validRange :: Lens' Tx SlotRange
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.ValidationData
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.ValidationData
instance GHC.Generics.Generic Ledger.Types.ValidationData
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.Tx
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.Tx
instance Codec.Serialise.Class.Serialise Ledger.Types.Tx
instance GHC.Generics.Generic Ledger.Types.Tx
instance GHC.Classes.Ord Ledger.Types.Tx
instance GHC.Classes.Eq Ledger.Types.Tx
instance GHC.Show.Show Ledger.Types.Tx
instance GHC.Classes.Ord Ledger.Types.TxStripped
instance GHC.Classes.Eq Ledger.Types.TxStripped
instance GHC.Show.Show Ledger.Types.TxStripped
instance GHC.Generics.Generic (Ledger.Types.TxOutOf h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (Ledger.Types.TxOutOf h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (Ledger.Types.TxOutOf h)
instance GHC.Show.Show h => GHC.Show.Show (Ledger.Types.TxOutOf h)
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.TxOutType
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.TxOutType
instance Codec.Serialise.Class.Serialise Ledger.Types.TxOutType
instance GHC.Generics.Generic Ledger.Types.TxOutType
instance GHC.Classes.Ord Ledger.Types.TxOutType
instance GHC.Classes.Eq Ledger.Types.TxOutType
instance GHC.Show.Show Ledger.Types.TxOutType
instance GHC.Generics.Generic (Ledger.Types.TxInOf h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (Ledger.Types.TxInOf h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (Ledger.Types.TxInOf h)
instance GHC.Show.Show h => GHC.Show.Show (Ledger.Types.TxInOf h)
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.TxInType
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.TxInType
instance Codec.Serialise.Class.Serialise Ledger.Types.TxInType
instance GHC.Generics.Generic Ledger.Types.TxInType
instance GHC.Classes.Ord Ledger.Types.TxInType
instance GHC.Classes.Eq Ledger.Types.TxInType
instance GHC.Show.Show Ledger.Types.TxInType
instance GHC.Generics.Generic (Ledger.Types.TxOutRefOf h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (Ledger.Types.TxOutRefOf h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (Ledger.Types.TxOutRefOf h)
instance GHC.Show.Show h => GHC.Show.Show (Ledger.Types.TxOutRefOf h)
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.RedeemerScript
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.RedeemerScript
instance Codec.Serialise.Class.Serialise Ledger.Types.RedeemerScript
instance GHC.Generics.Generic Ledger.Types.RedeemerScript
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.DataScript
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.DataScript
instance Codec.Serialise.Class.Serialise Ledger.Types.DataScript
instance GHC.Generics.Generic Ledger.Types.DataScript
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.ValidatorScript
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.ValidatorScript
instance Codec.Serialise.Class.Serialise Ledger.Types.ValidatorScript
instance GHC.Generics.Generic Ledger.Types.ValidatorScript
instance GHC.Classes.Ord Ledger.Types.Script
instance GHC.Classes.Eq Ledger.Types.Script
instance Codec.Serialise.Class.Serialise Ledger.Types.Script
instance GHC.Generics.Generic (Ledger.Types.AddressOf h)
instance GHC.Show.Show h => GHC.Show.Show (Ledger.Types.AddressOf h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (Ledger.Types.AddressOf h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (Ledger.Types.AddressOf h)
instance Codec.Serialise.Class.Serialise (Ledger.Types.TxIdOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Ledger.Types.TxIdOf a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Ledger.Types.TxIdOf a)
instance Data.Swagger.Internal.Schema.ToSchema a => Data.Swagger.Internal.Schema.ToSchema (Ledger.Types.TxIdOf a)
instance Codec.Serialise.Class.Serialise (Ledger.Types.AddressOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.ToJSON.ToJSON (Ledger.Types.AddressOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.FromJSON.FromJSON (Ledger.Types.AddressOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Codec.Serialise.Class.Serialise (Ledger.Types.TxOutRefOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.ToJSON.ToJSON (Ledger.Types.TxOutRefOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.FromJSON.FromJSON (Ledger.Types.TxOutRefOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Swagger.Internal.Schema.ToSchema (Ledger.Types.TxOutRefOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Codec.Serialise.Class.Serialise (Ledger.Types.TxInOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.ToJSON.ToJSON (Ledger.Types.TxInOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.FromJSON.FromJSON (Ledger.Types.TxInOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Codec.Serialise.Class.Serialise (Ledger.Types.TxOutOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.ToJSON.ToJSON (Ledger.Types.TxOutOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance Data.Aeson.Types.FromJSON.FromJSON (Ledger.Types.TxOutOf (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256))
instance GHC.Show.Show Ledger.Types.ValidationData
instance Data.ByteArray.Types.ByteArrayAccess Ledger.Types.Tx
instance Data.ByteArray.Types.ByteArrayAccess Ledger.Types.TxStripped
instance Data.ByteArray.Types.ByteArrayAccess Ledger.Types.TxOut
instance Data.ByteArray.Types.ByteArrayAccess Ledger.Types.TxIn
instance GHC.Show.Show Ledger.Types.RedeemerScript
instance GHC.Classes.Eq Ledger.Types.RedeemerScript
instance GHC.Classes.Ord Ledger.Types.RedeemerScript
instance Data.ByteArray.Types.ByteArrayAccess Ledger.Types.RedeemerScript
instance GHC.Show.Show Ledger.Types.DataScript
instance GHC.Classes.Eq Ledger.Types.DataScript
instance GHC.Classes.Ord Ledger.Types.DataScript
instance Data.ByteArray.Types.ByteArrayAccess Ledger.Types.DataScript
instance GHC.Show.Show Ledger.Types.ValidatorScript
instance GHC.Classes.Eq Ledger.Types.ValidatorScript
instance GHC.Classes.Ord Ledger.Types.ValidatorScript
instance Data.ByteArray.Types.ByteArrayAccess Ledger.Types.ValidatorScript
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.Script
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.Script
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Types.TxIdOf
instance (Language.PlutusTx.Lift.Class.Typeable h, Language.PlutusTx.Lift.Class.Lift h) => Language.PlutusTx.Lift.Class.Lift (Ledger.Types.TxIdOf h)
instance Codec.Serialise.Class.Serialise (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.ToJSON.ToJSON (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Swagger.Internal.Schema.ToSchema (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.FromJSON.FromJSON (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance GHC.Generics.Generic (Ledger.Types.TxIdOf h)
instance GHC.Show.Show h => GHC.Show.Show (Ledger.Types.TxIdOf h)
instance GHC.Classes.Ord h => GHC.Classes.Ord (Ledger.Types.TxIdOf h)
instance GHC.Classes.Eq h => GHC.Classes.Eq (Ledger.Types.TxIdOf h)
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Types.Value
instance Language.PlutusTx.Lift.Class.Lift Ledger.Types.Value
instance Codec.Serialise.Class.Serialise Ledger.Types.Value
instance GHC.Real.Real Ledger.Types.Value
instance GHC.Real.Integral Ledger.Types.Value
instance GHC.Num.Num Ledger.Types.Value
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.Value
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.Value
instance Data.Swagger.Internal.Schema.ToSchema Ledger.Types.Value
instance GHC.Generics.Generic Ledger.Types.Value
instance GHC.Enum.Enum Ledger.Types.Value
instance GHC.Show.Show Ledger.Types.Value
instance GHC.Classes.Ord Ledger.Types.Value
instance GHC.Classes.Eq Ledger.Types.Value
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Types.Signature
instance Language.PlutusTx.Lift.Class.Lift Ledger.Types.Signature
instance Codec.Serialise.Class.Serialise Ledger.Types.Signature
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.Signature
instance Data.Swagger.Internal.Schema.ToSchema Ledger.Types.Signature
instance GHC.Generics.Generic Ledger.Types.Signature
instance GHC.Show.Show Ledger.Types.Signature
instance GHC.Classes.Ord Ledger.Types.Signature
instance GHC.Classes.Eq Ledger.Types.Signature
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Types.PubKey
instance Language.PlutusTx.Lift.Class.Lift Ledger.Types.PubKey
instance Codec.Serialise.Class.Serialise Ledger.Types.PubKey
instance Control.Newtype.Generics.Newtype Ledger.Types.PubKey
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Types.PubKey
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Types.PubKey
instance Data.Swagger.Internal.Schema.ToSchema Ledger.Types.PubKey
instance GHC.Generics.Generic Ledger.Types.PubKey
instance GHC.Show.Show Ledger.Types.PubKey
instance GHC.Classes.Ord Ledger.Types.PubKey
instance GHC.Classes.Eq Ledger.Types.PubKey

module Ledger.Validation

-- | A pending transaction as seen by validator scripts.
data PendingTx
PendingTx :: [PendingTxIn] -> [PendingTxOut] -> Value -> Value -> PendingTxIn -> SlotRange -> PendingTx

-- | Transaction inputs
[pendingTxInputs] :: PendingTx -> [PendingTxIn]
[pendingTxOutputs] :: PendingTx -> [PendingTxOut]
[pendingTxFee] :: PendingTx -> Value
[pendingTxForge] :: PendingTx -> Value

-- | PendingTxIn being validated
[pendingTxIn] :: PendingTx -> PendingTxIn
[pendingTxValidRange] :: PendingTx -> SlotRange

-- | Output of a pending transaction.
data PendingTxOut
PendingTxOut :: Value -> Maybe (ValidatorHash, DataScriptHash) -> PendingTxOutType -> PendingTxOut
[pendingTxOutValue] :: PendingTxOut -> Value

-- | Hashes of validator script and data script
[pendingTxOutHashes] :: PendingTxOut -> Maybe (ValidatorHash, DataScriptHash)
[pendingTxOutData] :: PendingTxOut -> PendingTxOutType
data PendingTxOutRef
PendingTxOutRef :: TxHash -> Int -> PendingTxOutRef

-- | Transaction whose outputs are consumed
[pendingTxOutRefId] :: PendingTxOutRef -> TxHash

-- | Index into the referenced transaction's list of outputs
[pendingTxOutRefIdx] :: PendingTxOutRef -> Int

-- | Input of a pending transaction.
data PendingTxIn
PendingTxIn :: PendingTxOutRef -> Either (ValidatorHash, RedeemerHash) Signature -> Value -> PendingTxIn
[pendingTxInRef] :: PendingTxIn -> PendingTxOutRef

-- | Tx input witness, hashes for Script input, or signature for a PubKey
[pendingTxInWitness] :: PendingTxIn -> Either (ValidatorHash, RedeemerHash) Signature

-- | Value consumed by this txn input
[pendingTxInValue] :: PendingTxIn -> Value
data PendingTxOutType

-- | Pub key address
PubKeyTxOut :: PubKey -> PendingTxOutType

-- | The data script of the pending transaction output (see note [Script
--   types in pending transactions])
DataTxOut :: PendingTxOutType
newtype DataScriptHash
DataScriptHash :: ByteString -> DataScriptHash
newtype RedeemerHash
RedeemerHash :: ByteString -> RedeemerHash

-- | PLC runtime representation of a `Digest SHA256`
newtype ValidatorHash
ValidatorHash :: ByteString -> ValidatorHash
newtype TxHash
TxHash :: ByteString -> TxHash
plcDataScriptHash :: DataScript -> DataScriptHash
plcValidatorDigest :: Digest SHA256 -> ValidatorHash
plcRedeemerHash :: RedeemerScript -> RedeemerHash
plcTxHash :: TxId -> TxHash
data OracleValue a
OracleValue :: PubKey -> Slot -> a -> OracleValue a
[ovSignature] :: OracleValue a -> PubKey
[ovSlot] :: OracleValue a -> Slot
[ovValue] :: OracleValue a -> a

-- | Check if a transaction was signed by a public key
txSignedBy :: Q (TExp (PendingTx -> PubKey -> Bool))

-- | Check if the input of a pending transaction was signed by a public key
txInSignedBy :: Q (TExp (PendingTxIn -> PubKey -> Bool))

-- | Returns the public key that locks the transaction output
pubKeyOutput :: Q (TExp (PendingTxOut -> Maybe PubKey))

-- | Returns the data script that is part of the pay-to-script transaction
--   output
scriptOutput :: Q (TExp (PendingTxOut -> Maybe (ValidatorHash, DataScriptHash)))

-- | Equality of public keys
eqPubKey :: Q (TExp (PubKey -> PubKey -> Bool))

-- | Equality of data scripts
eqDataScript :: Q (TExp (DataScriptHash -> DataScriptHash -> Bool))

-- | Equality of redeemer scripts
eqRedeemer :: Q (TExp (RedeemerHash -> RedeemerHash -> Bool))

-- | Equality of validator scripts
eqValidator :: Q (TExp (ValidatorHash -> ValidatorHash -> Bool))

-- | Equality of transactions
eqTx :: Q (TExp (TxHash -> TxHash -> Bool))

-- | PLC-compatible SHA-256 hash of a hashable value
plcSHA2_256 :: ByteString -> ByteString

-- | PLC-compatible SHA3-256 hash of a hashable value
plcSHA3_256 :: ByteString -> ByteString
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.TxHash
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.TxHash
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.RedeemerHash
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.RedeemerHash
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.DataScriptHash
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.DataScriptHash
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.ValidatorHash
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.ValidatorHash
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.OracleValue
instance (Language.PlutusTx.Lift.Class.Typeable a, Language.PlutusTx.Lift.Class.Lift a) => Language.PlutusTx.Lift.Class.Lift (Ledger.Validation.OracleValue a)
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.PendingTx
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.PendingTx
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.PendingTxIn
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.PendingTxIn
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.PendingTxOutRef
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.PendingTxOutRef
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.PendingTxOut
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.PendingTxOut
instance Language.PlutusTx.Lift.Class.Typeable Ledger.Validation.PendingTxOutType
instance Language.PlutusTx.Lift.Class.Lift Ledger.Validation.PendingTxOutType
instance GHC.Generics.Generic Ledger.Validation.PendingTx
instance GHC.Generics.Generic Ledger.Validation.PendingTxIn
instance GHC.Generics.Generic Ledger.Validation.PendingTxOutRef
instance GHC.Generics.Generic Ledger.Validation.TxHash
instance GHC.Classes.Eq Ledger.Validation.TxHash
instance GHC.Generics.Generic Ledger.Validation.RedeemerHash
instance GHC.Classes.Eq Ledger.Validation.RedeemerHash
instance GHC.Generics.Generic Ledger.Validation.PendingTxOut
instance GHC.Generics.Generic Ledger.Validation.DataScriptHash
instance GHC.Classes.Eq Ledger.Validation.DataScriptHash
instance Codec.Serialise.Class.Serialise Ledger.Validation.ValidatorHash
instance GHC.Generics.Generic Ledger.Validation.ValidatorHash
instance GHC.Classes.Eq Ledger.Validation.ValidatorHash
instance GHC.Generics.Generic (Ledger.Validation.OracleValue a)
instance GHC.Generics.Generic Ledger.Validation.PendingTxOutType
instance Data.Swagger.Internal.Schema.ToSchema Ledger.Validation.ValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Validation.ValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Validation.ValidatorHash


-- | An index of unspent transaction outputs, and some functions for
--   validating transactions using the UTXO index.
module Ledger.Index

-- | Context for validating transactions. We need access to the unspent
--   transaction outputs of the blockchain, and we can throw
--   <a>ValidationError</a>s
type ValidationMonad m = (MonadReader UtxoIndex m, MonadError ValidationError m)

-- | The transactions of a blockchain indexed by hash
newtype UtxoIndex
UtxoIndex :: Map TxOutRef TxOut -> UtxoIndex
[getIndex] :: UtxoIndex -> Map TxOutRef TxOut

-- | Add a transaction to the index
insert :: Tx -> UtxoIndex -> UtxoIndex

-- | Add a block of transactions to the index
insertBlock :: [Tx] -> UtxoIndex -> UtxoIndex

-- | Create an index of all transactions on the chain
initialise :: Blockchain -> UtxoIndex
data Validation a

-- | Run a <a>Validation</a> on a <a>UtxoIndex</a>
runValidation :: Validation a -> UtxoIndex -> Either ValidationError a

-- | Determine the unspent value that a [[TxOutRef]] refers to
lkpValue :: ValidationMonad m => TxOutRef -> m Value

-- | Find an unspent transaction output by its reference. Assumes that the
--   output for this reference exists. If you want to handle the lookup
--   error you can use <tt>runLookup</tt>. Determine the transaction output
--   that a [[TxOutRef']] refers to
lkpTxOut :: ValidationMonad m => TxOutRef -> m TxOut

-- | Match each input of the transaction with its output
lkpOutputs :: ValidationMonad m => Tx -> m [(TxIn, TxOut)]

-- | Reason why a transaction is invalid
data ValidationError

-- | A pay-to-pubkey output was consumed by a pay-to-script input or vice
--   versa
InOutTypeMismatch :: TxIn -> TxOut -> ValidationError

-- | The unspent transaction output consumed by a transaction input could
--   not be found (either because it was already spent, or because there
--   was no transaction with the given hash on the blockchain)
TxOutRefNotFound :: TxOutRef -> ValidationError

-- | (for pay-to-script outputs) The validator script provided in the
--   transaction input does not match the hash specified in the transaction
--   output
InvalidScriptHash :: DataScript -> ValidationError

-- | (for pay-to-pubkey outputs) The signature of the transaction input
--   does not match the public key of the transaction output
InvalidSignature :: PubKey -> Signature -> ValidationError

-- | The amount spent by the transaction differs from the amount consumed
--   by it
ValueNotPreserved :: Value -> Value -> ValidationError

-- | The transaction produces an output with a negative value
NegativeValue :: Tx -> ValidationError

-- | (for pay-to-script outputs) Evaluation of the validator script failed
ScriptFailure :: [String] -> ValidationError

-- | The current slot is not covered by the transaction's validity slot
--   range.
CurrentSlotOutOfRange :: Slot -> ValidationError

-- | Matching pair of transaction input and transaction output.
data InOutMatch
ScriptMatch :: TxIn -> ValidatorScript -> RedeemerScript -> DataScript -> (AddressOf (Digest SHA256)) -> InOutMatch
PubKeyMatch :: PubKey -> Signature -> InOutMatch

-- | Validate a transaction in a <a>ValidationMonad</a> context.
--   
--   This does the same as <a>validTx</a>, but more efficiently as it
--   doesn't compute the UTXO of a blockchain from scratch. It also gives a
--   more precise error: <a>ValidationError</a> instead of <a>False</a>.
validateTransaction :: ValidationMonad m => Slot -> Tx -> m ()
instance GHC.Show.Show Ledger.Index.InOutMatch
instance GHC.Classes.Ord Ledger.Index.InOutMatch
instance GHC.Classes.Eq Ledger.Index.InOutMatch
instance Control.Monad.Error.Class.MonadError Ledger.Index.ValidationError Ledger.Index.Validation
instance Control.Monad.Reader.Class.MonadReader Ledger.Index.UtxoIndex Ledger.Index.Validation
instance GHC.Base.Monad Ledger.Index.Validation
instance GHC.Base.Applicative Ledger.Index.Validation
instance GHC.Base.Functor Ledger.Index.Validation
instance GHC.Generics.Generic Ledger.Index.ValidationError
instance GHC.Show.Show Ledger.Index.ValidationError
instance GHC.Classes.Ord Ledger.Index.ValidationError
instance GHC.Classes.Eq Ledger.Index.ValidationError
instance GHC.Base.Monoid Ledger.Index.UtxoIndex
instance GHC.Base.Semigroup Ledger.Index.UtxoIndex
instance GHC.Show.Show Ledger.Index.UtxoIndex
instance GHC.Classes.Ord Ledger.Index.UtxoIndex
instance GHC.Classes.Eq Ledger.Index.UtxoIndex
instance Data.Aeson.Types.FromJSON.FromJSON Ledger.Index.ValidationError
instance Data.Aeson.Types.ToJSON.ToJSON Ledger.Index.ValidationError

module Ledger

module Wallet.Emulator.AddressMap

-- | A map of [[Address]]es and their unspent outputs
newtype AddressMap
AddressMap :: Map Address (Map TxOutRef TxOut) -> AddressMap
[getAddressMap] :: AddressMap -> Map Address (Map TxOutRef TxOut)

-- | Add an address with no unspent outputs. If the address already exists,
--   do nothing.
addAddress :: Address -> AddressMap -> AddressMap

-- | Add a list of [[Address]]es with no unspent outputs
addAddresses :: [Address] -> AddressMap -> AddressMap

-- | The total value of unspent outputs at an address
values :: AddressMap -> Map Address Value

-- | An [[AddressMap]] with the unspent outputs of a single transaction
fromTxOutputs :: Tx -> AddressMap

-- | A map of unspent transaction outputs to their addresses (the "inverse"
--   of [[AddressMap]], without the values
knownAddresses :: AddressMap -> Map TxOutRef Address

-- | Update the [[AddressMap]] with the inputs and outputs of a new
--   transaction. <a>updateAddresses</a> does not add or remove any keys
--   from its second argument.
updateAddresses :: Tx -> AddressMap -> AddressMap

-- | Restrict an [[AddressMap]] to a set of addresses.
restrict :: AddressMap -> Set Address -> AddressMap
instance Codec.Serialise.Class.Serialise Wallet.Emulator.AddressMap.AddressMap
instance GHC.Generics.Generic Wallet.Emulator.AddressMap.AddressMap
instance GHC.Show.Show Wallet.Emulator.AddressMap.AddressMap
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.AddressMap.AddressMap
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.AddressMap.AddressMap
instance GHC.Base.Semigroup Wallet.Emulator.AddressMap.AddressMap
instance GHC.Base.Monoid Wallet.Emulator.AddressMap.AddressMap
instance Control.Lens.At.Ixed Wallet.Emulator.AddressMap.AddressMap
instance Control.Lens.At.At Wallet.Emulator.AddressMap.AddressMap


-- | Interface between wallet and Plutus client
module Wallet.API

-- | Used by Plutus client to interact with wallet
class WalletAPI m
submitTxn :: WalletAPI m => Tx -> m ()
myKeyPair :: WalletAPI m => m KeyPair

-- | Create a payment that spends the specified value and returns any
--   leftover funds as change. Fails if we don't have enough funds.
createPaymentWithChange :: WalletAPI m => Value -> m (Set TxIn, Maybe TxOut)

-- | Register a [[EventHandler]] in `m ()` to be run when condition is
--   true.
--   
--   <ul>
--   <li>The action will be run once for each block where the condition
--   holds. For example, `register (slotRangeT (Interval 3 6)) a` causes
--   <tt>a</tt> to be run at blocks 3, 4, and 5.</li>
--   <li>Each time the wallet is notified of a new block, all triggers are
--   checked and the matching ones are run in an unspecified order.</li>
--   <li>The wallet will only watch "known" addresses. There are two ways
--   an address can become a known address. 1. When a trigger is registered
--   for it 2. When a transaction submitted by this wallet produces an
--   output for it When an address is added to the set of known addresses,
--   it starts out with an initial value of 0. If there already exist
--   unspent transaction outputs at that address on the chain, then those
--   will be ignored.</li>
--   <li>`register c a &gt;&gt; register c b = register c (a &gt;&gt;
--   b)`</li>
--   </ul>
register :: WalletAPI m => EventTrigger -> EventHandler m -> m ()
watchedAddresses :: WalletAPI m => m AddressMap
startWatching :: WalletAPI m => Address -> m ()
slot :: WalletAPI m => m Slot

-- | The ability to log messages and throw errors
class MonadError WalletAPIError m => WalletDiagnostics m

-- | Write some information to the log
logMsg :: WalletDiagnostics m => Text -> m ()

-- | An action than can be run in response to a blockchain event. It
--   receives its [[EventTrigger]] annotated with truth values.
newtype EventHandler m
EventHandler :: AnnotatedEventTrigger Bool -> m () -> EventHandler m
[runEventHandler] :: EventHandler m -> AnnotatedEventTrigger Bool -> m ()
newtype KeyPair
KeyPair :: (PrivateKey, PubKey) -> KeyPair
[getKeyPair] :: KeyPair -> (PrivateKey, PubKey)

-- | Public key
newtype PubKey
PubKey :: Int -> PubKey
[getPubKey] :: PubKey -> Int

-- | Get the public key of a [[KeyPair]]
pubKey :: KeyPair -> PubKey

-- | Create a [[KeyPair]] given a "private key"
keyPair :: Int -> KeyPair

-- | Create a [[Signature]] signed by the private key of a [[KeyPair]]
signature :: KeyPair -> Signature
createPayment :: (Functor m, WalletAPI m) => Value -> m (Set TxIn)

-- | Create a transaction and submit it. TODO: Also compute the fee
createTxAndSubmit :: (Monad m, WalletAPI m) => SlotRange -> Set TxIn -> [TxOut] -> m Tx

-- | Transfer some funds to an address locked by a script, returning the
--   transaction that was submitted.
payToScript :: (Monad m, WalletAPI m) => SlotRange -> Address -> Value -> DataScript -> m Tx

-- | Transfer some funds to an address locked by a script.
payToScript_ :: (Monad m, WalletAPI m) => SlotRange -> Address -> Value -> DataScript -> m ()

-- | Transfer some funds to an address locked by a public key, returning
--   the transaction that was submitted.
payToPublicKey :: (Monad m, WalletAPI m) => SlotRange -> Value -> PubKey -> m Tx

-- | Transfer some funds to an address locked by a public key
payToPublicKey_ :: (Monad m, WalletAPI m) => SlotRange -> Value -> PubKey -> m ()

-- | Transfer some funds to a number of script addresses, returning the
--   transaction that was submitted.
payToScripts :: (Monad m, WalletAPI m) => SlotRange -> [(Address, Value, DataScript)] -> m Tx

-- | Transfer some funds to a number of script addresses.
payToScripts_ :: (Monad m, WalletAPI m) => SlotRange -> [(Address, Value, DataScript)] -> m ()

-- | Collect all unspent outputs from a pay to script address and transfer
--   them to a public key owned by us.
collectFromScript :: (Monad m, WalletAPI m) => SlotRange -> ValidatorScript -> RedeemerScript -> m ()

-- | Given the pay to script address of the <a>ValidatorScript</a>, collect
--   from it all the inputs that were produced by a specific transaction,
--   using the <a>RedeemerScript</a>.
collectFromScriptTxn :: (Monad m, WalletAPI m) => SlotRange -> ValidatorScript -> RedeemerScript -> TxId -> m ()

-- | Create a <a>TxOut</a> that pays to a public key owned by us
ownPubKeyTxOut :: (Monad m, WalletAPI m) => Value -> m TxOut

-- | Get the public key for this wallet
ownPubKey :: (Functor m, WalletAPI m) => m PubKey

-- | Generate a <a>Signature</a> with the wallet's own private key
ownSignature :: (Functor m, WalletAPI m) => m Signature

-- | An interval of <tt>a</tt>s. The interval is closed below and open
--   above, meaning that <tt>Interval (Just (10 :: Int)) (Just 11)</tt>
--   contains a single value <tt>11</tt>. The interval is unbounded on
--   either side: <tt>Interval Nothing (Just 12)</tt> contains all numbers
--   smaller than <tt>12</tt>.
data Interval a
Interval :: Maybe a -> Maybe a -> Interval a
[ivFrom] :: Interval a -> Maybe a
[ivTo] :: Interval a -> Maybe a
type SlotRange = Interval Slot

-- | An open-ended <a>SlotRange</a> that begins at slot 1.
defaultSlotRange :: SlotRange

-- | An inclusive-exclusive interval
interval :: a -> a -> Interval a

-- | <tt>intervalFrom a</tt> includes all values greater than or equal to
--   <tt>a</tt>, including <tt>a</tt> itself.
intervalFrom :: a -> Interval a

-- | <tt>intervalTo a</tt> includes all values smaller than <tt>a</tt>, but
--   not <tt>a</tt> itself.
intervalTo :: a -> Interval a

-- | A <a>SlotRange</a> that covers a single slot
singleton :: Slot -> SlotRange

-- | Check whether a <a>SlotRange</a> is empty
empty :: SlotRange -> Bool

-- | A <a>SlotRange</a> that covers all the slots
always :: SlotRange

-- | Check whether an <a>Interval</a> <tt>a</tt> includes an <tt>a</tt>.
member :: Ord a => a -> Interval a -> Bool

-- | The number of slots included in the <a>SlotRange</a>
width :: SlotRange -> Maybe Int

-- | Check if a <a>Slot</a> is before a <a>SlotRange</a>
before :: Slot -> SlotRange -> Bool

-- | Check if a <a>Slot</a> is after a <a>SlotRange</a>
after :: Slot -> SlotRange -> Bool
contains :: SlotRange -> SlotRange -> Bool
type EventTrigger = Fix EventTriggerF

-- | An [[EventTrigger]] where each level is annotated with a value of
--   <tt>a</tt>
type AnnotatedEventTrigger a = Fix (Compose ((,) a) EventTriggerF)
data EventTriggerF f
TAnd :: f -> f -> EventTriggerF f
TOr :: f -> f -> EventTriggerF f
TNot :: f -> EventTriggerF f
TAlways :: EventTriggerF f
TNever :: EventTriggerF f
TSlotRange :: !SlotRange -> EventTriggerF f
TFundsAtAddress :: !Address -> !(Interval Value) -> EventTriggerF f

-- | `andT l r` is true when <tt>l</tt> and <tt>r</tt> are true.
andT :: EventTrigger -> EventTrigger -> EventTrigger

-- | `orT l r` is true when <tt>l</tt> or <tt>r</tt> are true.
orT :: EventTrigger -> EventTrigger -> EventTrigger

-- | `notT t` is true when <tt>t</tt> is false
notT :: EventTrigger -> EventTrigger

-- | <a>alwaysT</a> is always true
alwaysT :: EventTrigger

-- | <a>neverT</a> is never true
neverT :: EventTrigger

-- | `slotRangeT r` is true when the slot number is in the range <tt>r</tt>
slotRangeT :: SlotRange -> EventTrigger

-- | `fundsAtAddressT a r` is true when the funds at <tt>a</tt> are in the
--   range <tt>r</tt>
fundsAtAddressT :: Address -> Interval Value -> EventTrigger

-- | Check if the given slot number and UTXOs match the conditions of an
--   [[EventTrigger]]
checkTrigger :: Slot -> Map Address Value -> EventTrigger -> Bool

-- | The addresses that an [[EventTrigger]] refers to
addresses :: EventTrigger -> [Address]
getAnnot :: AnnotatedEventTrigger a -> a

-- | Annotate each node in an <a>EventTriggerF</a> with its truth value
--   given a slot and a set of unspent outputs
annTruthValue :: Slot -> Map Address Value -> EventTrigger -> AnnotatedEventTrigger Bool
data WalletAPIError
InsufficientFunds :: Text -> WalletAPIError
OtherError :: Text -> WalletAPIError
throwInsufficientFundsError :: MonadError WalletAPIError m => Text -> m a
throwOtherError :: MonadError WalletAPIError m => Text -> m a
newtype WalletLog
WalletLog :: [Text] -> WalletLog
[getWalletLog] :: WalletLog -> [Text]
instance GHC.Base.Monoid Wallet.API.WalletLog
instance GHC.Base.Semigroup Wallet.API.WalletLog
instance GHC.Generics.Generic Wallet.API.WalletLog
instance GHC.Show.Show Wallet.API.WalletLog
instance GHC.Classes.Ord Wallet.API.WalletLog
instance GHC.Classes.Eq Wallet.API.WalletLog
instance GHC.Generics.Generic Wallet.API.WalletAPIError
instance GHC.Classes.Ord Wallet.API.WalletAPIError
instance GHC.Classes.Eq Wallet.API.WalletAPIError
instance GHC.Show.Show Wallet.API.WalletAPIError
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.API.WalletLog
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.API.WalletLog
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.API.WalletAPIError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.API.WalletAPIError
instance GHC.Base.Monad m => GHC.Base.Semigroup (Wallet.API.EventHandler m)
instance GHC.Base.Monad m => GHC.Base.Monoid (Wallet.API.EventHandler m)
instance Data.Functor.Classes.Show1 Wallet.API.EventTriggerF
instance Data.Functor.Classes.Ord1 Wallet.API.EventTriggerF
instance Data.Functor.Classes.Eq1 Wallet.API.EventTriggerF
instance GHC.Generics.Generic (Wallet.API.EventTriggerF f)
instance Data.Traversable.Traversable Wallet.API.EventTriggerF
instance Data.Foldable.Foldable Wallet.API.EventTriggerF
instance GHC.Base.Functor Wallet.API.EventTriggerF
instance GHC.Show.Show f => GHC.Show.Show (Wallet.API.EventTriggerF f)
instance GHC.Classes.Ord f => GHC.Classes.Ord (Wallet.API.EventTriggerF f)
instance GHC.Classes.Eq f => GHC.Classes.Eq (Wallet.API.EventTriggerF f)
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.API.KeyPair
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.API.KeyPair
instance GHC.Show.Show Wallet.API.KeyPair
instance GHC.Classes.Ord Wallet.API.KeyPair
instance GHC.Classes.Eq Wallet.API.KeyPair
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.API.PrivateKey
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.API.PrivateKey
instance GHC.Show.Show Wallet.API.PrivateKey
instance GHC.Classes.Ord Wallet.API.PrivateKey
instance GHC.Classes.Eq Wallet.API.PrivateKey

module Wallet

module Wallet.Emulator.Types
newtype Wallet
Wallet :: Int -> Wallet
[getWallet] :: Wallet -> Int
type TxPool = [Tx]
data Assertion
IsValidated :: Tx -> Assertion
OwnFundsEqual :: Wallet -> Value -> Assertion
assert :: (MonadEmulator m) => Assertion -> m ()
assertIsValidated :: Tx -> Trace m ()
data AssertionError

-- | The type of events in the emulator. <tt>n</tt> is the type (usually a
--   monad) in which wallet actions take place.
data Event n a

-- | An direct action performed by a wallet. Usually represents a "user
--   action", as it is triggered externally.
[WalletAction] :: Wallet -> n () -> Event n [Tx]

-- | A wallet receiving some notifications, and reacting to them.
[WalletRecvNotification] :: Wallet -> [Notification] -> Event n [Tx]

-- | The blockchain processing pending transactions, producing a new block
--   from the valid ones and discarding the invalid ones.
[BlockchainProcessPending] :: Event n Block

-- | An assertion in the event stream, which can inspect the current state.
[Assertion] :: Assertion -> Event n ()
data Notification
BlockValidated :: Block -> Notification
CurrentSlot :: Slot -> Notification

-- | Events produced by the mockchain
data EmulatorEvent

-- | A transaction has been added to the global pool of pending
--   transactions
TxnSubmit :: TxId -> EmulatorEvent

-- | A transaction has been validated and added to the blockchain
TxnValidate :: TxId -> EmulatorEvent

-- | A transaction failed to validate
TxnValidationFail :: TxId -> ValidationError -> EmulatorEvent

-- | A slot has passed, and a block was added to the blokchain
SlotAdd :: Slot -> EmulatorEvent

-- | A <a>WalletAPI</a> action produced an error
WalletError :: Wallet -> WalletAPIError -> EmulatorEvent

-- | Debug information produced by a wallet
WalletInfo :: Wallet -> Text -> EmulatorEvent
data WalletState
WalletState :: KeyPair -> Slot -> AddressMap -> Map EventTrigger (EventHandler MockWallet) -> WalletState
[_ownKeyPair] :: WalletState -> KeyPair

-- | Current slot as far as the wallet is concerned
[_walletSlot] :: WalletState -> Slot

-- | Addresses that we watch. For each address we keep the unspent
--   transaction outputs and their values, so that we can use them in
--   transactions.
[_addressMap] :: WalletState -> AddressMap
[_triggers] :: WalletState -> Map EventTrigger (EventHandler MockWallet)

-- | An empty wallet state with the public/private key pair for a wallet,
--   and the public key address for that wallet as the sole member of
--   <tt>walletStateWatchedAddresses</tt>
emptyWalletState :: Wallet -> WalletState
ownKeyPair :: Lens' WalletState KeyPair
ownFunds :: Lens' WalletState (Map TxOutRef TxOut)
addressMap :: Lens' WalletState AddressMap
walletSlot :: Lens' WalletState Slot
type Trace m = Program (Event m)

-- | Run an emulator trace on a blockchain
runTraceChain :: Blockchain -> Trace MockWallet a -> (Either AssertionError a, EmulatorState)

-- | Run an emulator trace on an empty blockchain with a pool of pending
--   transactions
runTraceTxPool :: TxPool -> Trace MockWallet a -> (Either AssertionError a, EmulatorState)

-- | Interact with a wallet
walletAction :: Wallet -> m () -> Trace m [Tx]

-- | Notify a wallet of blockchain events
walletRecvNotifications :: Wallet -> [Notification] -> Trace m [Tx]

-- | Notify a wallet that a block has been validated
walletNotifyBlock :: Wallet -> Block -> Trace m [Tx]

-- | Notify a list of wallets that a block has been validated
walletsNotifyBlock :: [Wallet] -> Block -> Trace m [Tx]

-- | Validate all pending transactions
processPending :: Trace m Block

-- | Add a number of empty blocks to the blockchain, by performing
--   <a>processPending</a> <tt>n</tt> times.
addBlocks :: Int -> Trace m [Block]

-- | Add a number of blocks, notifying all wallets after each block
addBlocksAndNotify :: [Wallet] -> Int -> Trace m ()

-- | Make an assertion about the emulator state
assertion :: Assertion -> Trace m ()
assertOwnFundsEq :: Wallet -> Value -> Trace m ()
newtype MockWallet a
MockWallet :: (ExceptT WalletAPIError (StateT WalletState (Writer (WalletLog, [Tx])))) a -> MockWallet a
[runMockWallet] :: MockWallet a -> (ExceptT WalletAPIError (StateT WalletState (Writer (WalletLog, [Tx])))) a
handleNotifications :: [Notification] -> MockWallet ()
data EmulatorState
EmulatorState :: Blockchain -> TxPool -> Map Wallet WalletState -> UtxoIndex -> [EmulatorEvent] -> EmulatorState
[_chainNewestFirst] :: EmulatorState -> Blockchain
[_txPool] :: EmulatorState -> TxPool
[_walletStates] :: EmulatorState -> Map Wallet WalletState
[_index] :: EmulatorState -> UtxoIndex

-- | emulator events, newest first
[_emulatorLog] :: EmulatorState -> [EmulatorEvent]
emptyEmulatorState :: EmulatorState

-- | Initialise the emulator state with a blockchain
emulatorState :: Blockchain -> EmulatorState
chainNewestFirst :: Lens' EmulatorState Blockchain

-- | The blockchain as a list of blocks, starting with the oldest (genesis)
--   block
chainOldestFirst :: Lens' EmulatorState Blockchain
txPool :: Lens' EmulatorState TxPool
walletStates :: Lens' EmulatorState (Map Wallet WalletState)
index :: Lens' EmulatorState UtxoIndex
type MonadEmulator m = (MonadState EmulatorState m, MonadError AssertionError m)

-- | Validate a transaction in the current emulator state
validateEm :: EmulatorState -> Tx -> Maybe ValidationError

-- | Validate a block in an [[EmulatorState]], returning the valid
--   transactions and all success/failure events
validateBlock :: EmulatorState -> [Tx] -> ValidatedBlock

-- | Result of validating a block
data ValidatedBlock
ValidatedBlock :: [Tx] -> [EmulatorEvent] -> [Tx] -> ValidatedBlock

-- | Transactions that have been validated
[vlbValid] :: ValidatedBlock -> [Tx]

-- | Transaction validation events
[vlbEvents] :: ValidatedBlock -> [EmulatorEvent]

-- | Transactions that haven't been validated because the current slot is
--   not in their validation interval
[vlbRest] :: ValidatedBlock -> [Tx]
liftMockWallet :: (MonadState EmulatorState m) => Wallet -> MockWallet a -> m ([Tx], Either WalletAPIError a)
evalEmulated :: (MonadEmulator m) => Event MockWallet a -> m a
processEmulated :: (MonadEmulator m) => Trace MockWallet a -> m a
runWalletActionAndProcessPending :: [Wallet] -> Wallet -> m () -> Trace m [Tx]
fundsDistribution :: EmulatorState -> Map Wallet Value

-- | Given a set of <tt>a</tt>s with coin values, and a target value,
--   select a number of <tt>a</tt> such that their total value is greater
--   than or equal to the target.
selectCoin :: (MonadError WalletAPIError m) => [(a, Value)] -> Value -> m ([(a, Value)], Value)
instance GHC.Show.Show Wallet.Emulator.Types.EmulatorState
instance GHC.Show.Show Wallet.Emulator.Types.AssertionError
instance GHC.Generics.Generic Wallet.Emulator.Types.EmulatorEvent
instance GHC.Show.Show Wallet.Emulator.Types.EmulatorEvent
instance GHC.Classes.Ord Wallet.Emulator.Types.EmulatorEvent
instance GHC.Classes.Eq Wallet.Emulator.Types.EmulatorEvent
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Types.EmulatorEvent
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Types.EmulatorEvent
instance Wallet.API.WalletAPI Wallet.Emulator.Types.MockWallet
instance Control.Monad.Writer.Class.MonadWriter (Wallet.API.WalletLog, [Ledger.Types.Tx]) Wallet.Emulator.Types.MockWallet
instance Control.Monad.Error.Class.MonadError Wallet.API.WalletAPIError Wallet.Emulator.Types.MockWallet
instance Control.Monad.State.Class.MonadState Wallet.Emulator.Types.WalletState Wallet.Emulator.Types.MockWallet
instance GHC.Base.Monad Wallet.Emulator.Types.MockWallet
instance GHC.Base.Applicative Wallet.Emulator.Types.MockWallet
instance GHC.Base.Functor Wallet.Emulator.Types.MockWallet
instance GHC.Classes.Ord Wallet.Emulator.Types.Notification
instance GHC.Classes.Eq Wallet.Emulator.Types.Notification
instance GHC.Show.Show Wallet.Emulator.Types.Notification
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Emulator.Types.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Types.Wallet
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Types.Wallet
instance Control.Newtype.Generics.Newtype Wallet.Emulator.Types.Wallet
instance Data.Hashable.Class.Hashable Wallet.Emulator.Types.Wallet
instance Web.Internal.HttpApiData.FromHttpApiData Wallet.Emulator.Types.Wallet
instance Web.Internal.HttpApiData.ToHttpApiData Wallet.Emulator.Types.Wallet
instance GHC.Generics.Generic Wallet.Emulator.Types.Wallet
instance GHC.Classes.Ord Wallet.Emulator.Types.Wallet
instance GHC.Classes.Eq Wallet.Emulator.Types.Wallet
instance GHC.Show.Show Wallet.Emulator.Types.Wallet
instance Wallet.API.WalletDiagnostics Wallet.Emulator.Types.MockWallet
instance GHC.Show.Show Wallet.Emulator.Types.WalletState

module Wallet.Emulator.Http
app :: ServerState -> Application
initialState :: IO ServerState
type API = WalletAPI :<|> WalletControlAPI :<|> ControlAPI :<|> AssertionsAPI
instance Control.Monad.Error.Class.MonadError Servant.Server.Internal.ServantErr.ServantErr Wallet.Emulator.Http.AppM
instance Control.Monad.IO.Class.MonadIO Wallet.Emulator.Http.AppM
instance Control.Monad.Reader.Class.MonadReader Wallet.Emulator.Http.ServerState Wallet.Emulator.Http.AppM
instance GHC.Base.Monad Wallet.Emulator.Http.AppM
instance GHC.Base.Applicative Wallet.Emulator.Http.AppM
instance GHC.Base.Functor Wallet.Emulator.Http.AppM

module Wallet.Emulator.Client
data Environment
Environment :: Wallet -> ClientEnv -> Environment
data WalletClient a
runWalletClient :: Environment -> WalletClient a -> IO (Either ServantError (a, [Tx]))
wallets :: ClientM [Wallet]
fetchWallet :: Wallet -> ClientM Wallet
createWallet :: Wallet -> ClientM NoContent
getTransactions :: ClientM [Tx]
blockValidated :: Wallet -> Block -> ClientM ()
slot :: WalletAPI m => m Slot
processPending :: ClientM [Tx]
assertOwnFundsEq :: Wallet -> Value -> ClientM NoContent
assertIsValidated :: Tx -> ClientM NoContent
process :: ClientEnv -> Trace WalletClient a -> ExceptT ServantError IO a
instance Control.Monad.Writer.Class.MonadWriter [Ledger.Types.Tx] Wallet.Emulator.Client.WalletClient
instance Control.Monad.Reader.Class.MonadReader Wallet.Emulator.Client.Environment Wallet.Emulator.Client.WalletClient
instance GHC.Base.Monad Wallet.Emulator.Client.WalletClient
instance GHC.Base.Applicative Wallet.Emulator.Client.WalletClient
instance GHC.Base.Functor Wallet.Emulator.Client.WalletClient
instance Wallet.API.WalletAPI Wallet.Emulator.Client.WalletClient

module Wallet.Emulator

module Wallet.Generators

-- | Blockchain for testing the emulator implementation and traces.
--   
--   To avoid having to rely on functions from the implementation of
--   wallet-api (in particular, <a>unspentOutputs</a>) we note the unspent
--   outputs of the chain when it is first created.
data Mockchain
Mockchain :: Block -> Map TxOutRef TxOut -> Mockchain
[mockchainInitialBlock] :: Mockchain -> Block
[mockchainUtxo] :: Mockchain -> Map TxOutRef TxOut

-- | Generate a mockchain using the default [[GeneratorModel]]
genMockchain :: MonadGen m => m Mockchain

-- | Generate a mockchain
--   
--   TODO: Generate more than 1 txn
genMockchain' :: MonadGen m => GeneratorModel -> m Mockchain

-- | The empty mockchain
emptyChain :: Mockchain
data GeneratorModel
GeneratorModel :: Map PubKey Value -> Set PubKey -> GeneratorModel

-- | Value created at the beginning of the blockchain
[gmInitialBalance] :: GeneratorModel -> Map PubKey Value

-- | Public keys that are to be used for generating transactions
[gmPubKeys] :: GeneratorModel -> Set PubKey

-- | A generator model with some sensible defaults
generatorModel :: GeneratorModel

-- | Estimate a transaction fee based on the number of its inputs and
--   outputs.
newtype FeeEstimator
FeeEstimator :: Int -> Int -> Value -> FeeEstimator
[estimateFee] :: FeeEstimator -> Int -> Int -> Value

-- | A constant fee for all transactions
constantFee :: Value -> FeeEstimator

-- | Generate a valid transaction, using the unspent outputs provided.
--   Fails if the there are no unspent outputs, or if the total value of
--   the unspent outputs is smaller than the minimum fee (1)
genValidTransaction :: MonadGen m => Mockchain -> m Tx

-- | Generate a valid transaction, using the unspent outputs provided.
--   Fails if the there are no unspent outputs, or if the total value of
--   the unspent outputs is smaller than the estimated fee.
genValidTransaction' :: MonadGen m => GeneratorModel -> FeeEstimator -> Mockchain -> m Tx
genValidTransactionSpending :: MonadGen m => Set TxIn -> Value -> m Tx
genValidTransactionSpending' :: MonadGen m => GeneratorModel -> FeeEstimator -> Set TxIn -> Value -> m Tx

-- | A transaction with no inputs that forges some value (to be used at the
--   beginning of a blockchain)
genInitialTransaction :: GeneratorModel -> (Tx, [TxOut])

-- | Assert that a transaction is valid in a chain
assertValid :: (MonadTest m, HasCallStack) => Tx -> Mockchain -> m ()
genValue :: MonadGen m => m Value

-- | Run an emulator trace on a mockchain
runTrace :: Mockchain -> Trace MockWallet a -> (Either AssertionError a, EmulatorState)

-- | Run an emulator trace on a mockchain generated by the model
runTraceOn :: MonadGen m => GeneratorModel -> Trace MockWallet a -> m (Either AssertionError a, EmulatorState)

-- | Split a value into max. n positive-valued parts such that the sum of
--   the parts equals the original value.
splitVal :: (MonadGen m, Integral n) => Int -> n -> m [n]

-- | Validate a transaction in a mockchain
validateMockchain :: Mockchain -> Tx -> Maybe ValidationError
instance GHC.Show.Show Wallet.Generators.Mockchain
instance GHC.Show.Show Wallet.Generators.GeneratorModel


-- | Support for visualisation of a mockchain as a graph.
module Wallet.Graph

-- | The flows of value from t
txnFlows :: [PubKey] -> Blockchain -> [FlowLink]
graph :: [FlowLink] -> FlowGraph
data FlowGraph
data FlowLink

-- | Wrapper around the first 8 digits of a <a>TxId</a>
data TxRef

-- | Owner of unspent funds
data UtxOwner
data UtxoLocation
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.FlowGraph
instance GHC.Generics.Generic Wallet.Graph.FlowGraph
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.FlowLink
instance GHC.Generics.Generic Wallet.Graph.FlowLink
instance GHC.Show.Show Wallet.Graph.FlowLink
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.UtxoLocation
instance GHC.Generics.Generic Wallet.Graph.UtxoLocation
instance GHC.Show.Show Wallet.Graph.UtxoLocation
instance GHC.Classes.Ord Wallet.Graph.UtxoLocation
instance GHC.Classes.Eq Wallet.Graph.UtxoLocation
instance GHC.Generics.Generic Wallet.Graph.TxRef
instance GHC.Show.Show Wallet.Graph.TxRef
instance GHC.Classes.Ord Wallet.Graph.TxRef
instance GHC.Classes.Eq Wallet.Graph.TxRef
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.UtxOwner
instance GHC.Generics.Generic Wallet.Graph.UtxOwner
instance GHC.Show.Show Wallet.Graph.UtxOwner
instance GHC.Classes.Ord Wallet.Graph.UtxOwner
instance GHC.Classes.Eq Wallet.Graph.UtxOwner
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.TxRef
